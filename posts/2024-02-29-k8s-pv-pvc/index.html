<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[KR] Kubernetes - PV & PVC | Wonyoung's Tech Blog</title><meta name=keywords content="kubernetes,k8s"><meta name=description content="데이터를 영구적으로 저장하는 매커니즘 Persistent Storage
 PV / PVC 의 주요 개념 PV (Persistent Volume)  K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오. 관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨 일반 볼륨과의 차이점  일반 볼륨은 Pod와 같은 라이프사이클을 가짐. 함께 생성되고 함께 내려간다는 뜻 PV는 Pod와 별개의 라이프사이클을 가지므로, Pod가 종료되어도 PV에 기록된 데이터는 삭제되지 않음    PV 생성하기 # ex) pv-definition."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://wonyoungseo.github.io/posts/2024-02-29-k8s-pv-pvc/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="[KR] Kubernetes - PV & PVC"><meta property="og:description" content="데이터를 영구적으로 저장하는 매커니즘 Persistent Storage
 PV / PVC 의 주요 개념 PV (Persistent Volume)  K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오. 관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨 일반 볼륨과의 차이점  일반 볼륨은 Pod와 같은 라이프사이클을 가짐. 함께 생성되고 함께 내려간다는 뜻 PV는 Pod와 별개의 라이프사이클을 가지므로, Pod가 종료되어도 PV에 기록된 데이터는 삭제되지 않음    PV 생성하기 # ex) pv-definition."><meta property="og:type" content="article"><meta property="og:url" content="https://wonyoungseo.github.io/posts/2024-02-29-k8s-pv-pvc/"><meta property="og:image" content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2024-02-29T03:18:50+09:00"><meta property="article:modified_time" content="2024-02-29T03:18:50+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[KR] Kubernetes - PV & PVC"><meta name=twitter:description content="데이터를 영구적으로 저장하는 매커니즘 Persistent Storage
 PV / PVC 의 주요 개념 PV (Persistent Volume)  K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오. 관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨 일반 볼륨과의 차이점  일반 볼륨은 Pod와 같은 라이프사이클을 가짐. 함께 생성되고 함께 내려간다는 뜻 PV는 Pod와 별개의 라이프사이클을 가지므로, Pod가 종료되어도 PV에 기록된 데이터는 삭제되지 않음    PV 생성하기 # ex) pv-definition."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[KR] Kubernetes - PV \u0026 PVC","name":"[KR] Kubernetes - PV \u0026 PVC","description":"데이터를 영구적으로 저장하는 매커니즘 Persistent Storage\n PV / PVC 의 주요 개념 PV (Persistent Volume)  K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오. 관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨 일반 볼 …","keywords":["kubernetes","k8s"],"articleBody":" 데이터를 영구적으로 저장하는 매커니즘 Persistent Storage\n PV / PVC 의 주요 개념 PV (Persistent Volume)  K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오. 관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨 일반 볼륨과의 차이점  일반 볼륨은 Pod와 같은 라이프사이클을 가짐. 함께 생성되고 함께 내려간다는 뜻 PV는 Pod와 별개의 라이프사이클을 가지므로, Pod가 종료되어도 PV에 기록된 데이터는 삭제되지 않음    PV 생성하기 # ex) pv-definition.yaml apiVersion: v1 kind: PersistentVolume metadata: name: pv-vol-1 spec: accessModes: # 스토리지 볼륨 접근 방식 - ReadWriteOnce  capacity: storage: 1Gi # PV로 선점하고자 하는 용량 # 볼륨 타입 정의 hostPath: # hostPath 는 해당 노드의 local directory이므로, 프로덕션에서는 권장되지 않음. path: /tmp/data awsElasticBlockStore: volumeID:  fsType: ext4  생성: kubectl create -f pv-definition.yaml 조회: kubectl get persistentvolume  accessModes 유형\n ReadOnlyMany ReadWriteOnce ReadWriteMany  PVC (Persistent Volume Claim)  Persistent Volume (PV) 을 사용할 수 있게끔 유저가 생성하는 오브젝트 PVC가 생성되면 K8s는 이를 기반으로 PVC에서 요청한 기준에 부합하는 (그리고 용량이 여유가 있는) PV를 찾아 PVC 와 바인드(bind) 함 만일 조건에 부합하는 PV가 여러개 존재하는 경우에는 label과 selector를 써서 매칭 함 만일 최적의 매칭 조합을 찾지 못해 PVC에서 정의된 용량보다 더 큰 용량의 PV와 바인드가 되면, 남아도는 용량은 다른 PVC가 사용할 수 없게 됨 (PV와 PVC는 1:1 매칭) 이후 더 이상 가용할 수 있는 PV가 없는 상태에서 PVC가 생성되면, 매칭 가능한 PV가 추가되기 전까지는 바인딩이 pending 됨. 만일 다음과 같이 생성된 PV가 유일한 PV이고, 이어서 PVC가 생성된다면, 용량은 부합하지 않지만, 다른 선택지가 없으므로 매칭됨.  PVC 생성하기 PV 정의 및 생성\n# ex) pv-definition.yaml apiVersion: v1 kind: PersistentVolume metadata: name: pv-vol-1 spec: accessModes: - ReadWriteOnce  capacity: storage: 1Gi  awsElasticBlockStore: volumeID:  fsType: ext4 persistentVolumeReclaimPolicy: Retain # default PV에 매칭되는 PVC 정의\n# ex) pvc-definition.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: myclaim spec: accessModes: - ReadWriteOnce resources: requests: storage: 500Mi  생성: kubectl -f pvc-definition.yaml 조회: kubectl get persistentvolumeclaim  PVC 바인딩 방법  PVC를 사용하고자 할 때, Pod 정의는 아래 yaml 파일과 같음. ReplicaSet과 Deployment에서도 동일하게 적용  # ex) pod-definition.yaml apiVersion: v1 kind: Pod metadata: name: random-number-generator spec: containers: - image: alpine name: alpine command: [\"/bin/sh\", \"-c\"] args: [\"shuf -i 0-100 -n 1  /opt/number.out;\"] volumeMounts: - mountPath: /opt name: data-volume # 볼륨 생성 volumes: - name: random-number-generator persistentVolumeClaim: claimName: myclaim PVC 삭제  삭제: kubectl delete persistentvolumeclaime   단, PVC가 삭제되더라도 persistentVolumeReclaimPolicy: Retain 으로 설정되어 있기 때문에, 매뉴얼로 삭제하지 않는 한, PV는 삭제되지 않음.\npersistentVolumeReclaimPolicy: Delete 으로 설정된 경우, PVC가 삭제되면 PV도 함께 삭제됨.\nPV / PVC 의 라이프사이클 (Lifecycle of a volume) 2.1. 프로비저닝  정적 프로비저닝  스토리지 기술을 명세해서 PV를 사전에 만드는 방식 리소스가 한정된 온프레미스 환경에서 사용 PV 생성 이후 PV 리소스를 사용하겠다는 PVC를 생성  PVC에서 storageClassName: '' 의 설정 유의 미리 생성한 PV 안에서 가능한 PV를 바인딩하겠다는 뜻   이후 Pod에서 PVC를 참조하면 PV를 사용할 수 있게 됨 Note:  PVC를 설정하지 않고, Pod 생성 시 곧장 PV를 참조할 수도 있음 PVC 활용은 기존 Storage의 기술을 자세히 알지 못 하더라도 PV만 명시하면 K8s가 알아서 자원을 할당시켜주기 때문에 용이함. (따라서 권장사항)     동적 프로비저닝  PV 프로비저너를 배포하고 storage class만 명시하면 동적으로 프로비저닝 함. PVC에서 stroageClassName만 제공하면 프로비저너가 알아서 PV를 생성해주고 PVC와 연결도 해줌. GKE를 비롯한 Cloud Service에서는 PV 프로비저너를 제공함.    2.2. 바인딩  PV와 PVC가 연결되는 동작. 정적 프로비저닝  PVC를 배포하면 쿠버네티스가 가능한 PV안에서 PVC를 바인딩해줌. 동적 프로비저닝의 경우는 Storage Class의 Provisioner가 PV를 동적으로 생성하고 PVC와 바인딩해줌.    2.3. 사용, 사용 중  바인딩 이후로 PV는 Pod에 속해 사용 됨.  2.4. 반환 (Reclaiming)  볼륨을 다 사용한 뒤, 리소스 반환 API를 사용해 PVC 오브젝트를 삭제할 수 있음. PVC의 반환  볼륨에서 클레임 해제 볼륨에 수행할 작업을 클러스터에 알려줌   볼륨의 반환 정책  Retain  리소스를 수동으로 반환하는 정책 PVC삭제되어도 PV는 존재하기에, 관리자가 수동으로 볼륨을 반환해야 함   Delete  PV와 외부 인프라 등, 관련된 스토리지 자산을 모두 삭제함. 동적 프로비저닝 된 볼륨의 경우에는 Storage Class의 반환 정책을 상속받음.   Recycle (deprecated)    Reference Persistent Volumes\n쿠버네티스(k8s) Persistent Storage란?\n","wordCount":"610","inLanguage":"en","datePublished":"2024-02-29T03:18:50+09:00","dateModified":"2024-02-29T03:18:50+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wonyoungseo.github.io/posts/2024-02-29-k8s-pv-pvc/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wonyoungseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wonyoungseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://wonyoungseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wonyoungseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wonyoungseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://wonyoungseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[KR] Kubernetes - PV & PVC</h1><div class=post-meta>February 29, 2024&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#pv--pvc-%ec%9d%98-%ec%a3%bc%ec%9a%94-%ea%b0%9c%eb%85%90 aria-label="PV / PVC 의 주요 개념">PV / PVC 의 주요 개념</a><ul><li><a href=#pv-persistent-volume aria-label="PV (Persistent Volume)">PV (Persistent Volume)</a><ul><li><a href=#pv-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="PV 생성하기">PV 생성하기</a></li></ul></li><li><a href=#pvc-persistent-volume-claim aria-label="PVC (Persistent Volume Claim)">PVC (Persistent Volume Claim)</a><ul><li><a href=#pvc-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="PVC 생성하기">PVC 생성하기</a></li><li><a href=#pvc-%eb%b0%94%ec%9d%b8%eb%94%a9-%eb%b0%a9%eb%b2%95 aria-label="PVC 바인딩 방법">PVC 바인딩 방법</a></li><li><a href=#pvc-%ec%82%ad%ec%a0%9c aria-label="PVC 삭제">PVC 삭제</a></li></ul></li></ul></li><li><a href=#pv--pvc-%ec%9d%98-%eb%9d%bc%ec%9d%b4%ed%94%84%ec%82%ac%ec%9d%b4%ed%81%b4-lifecycle-of-a-volume aria-label="PV / PVC 의 라이프사이클 (Lifecycle of a volume)">PV / PVC 의 라이프사이클 (Lifecycle of a volume)</a><ul><li><a href=#21-%ed%94%84%eb%a1%9c%eb%b9%84%ec%a0%80%eb%8b%9d aria-label="2.1. 프로비저닝">2.1. 프로비저닝</a></li><li><a href=#22-%eb%b0%94%ec%9d%b8%eb%94%a9 aria-label="2.2. 바인딩">2.2. 바인딩</a></li><li><a href=#23-%ec%82%ac%ec%9a%a9-%ec%82%ac%ec%9a%a9-%ec%a4%91 aria-label="2.3. 사용, 사용 중">2.3. 사용, 사용 중</a></li><li><a href=#24-%eb%b0%98%ed%99%98-reclaiming aria-label="2.4. 반환 (Reclaiming)">2.4. 반환 (<strong>Reclaiming)</strong></a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><blockquote><p>데이터를 영구적으로 저장하는 매커니즘 Persistent Storage</p></blockquote><h1 id=pv--pvc-의-주요-개념>PV / PVC 의 주요 개념<a hidden class=anchor aria-hidden=true href=#pv--pvc-의-주요-개념>#</a></h1><h2 id=pv-persistent-volume>PV (Persistent Volume)<a hidden class=anchor aria-hidden=true href=#pv-persistent-volume>#</a></h2><ul><li>K8s 어드민이 설정한 클러스터 레벨의 스토리지 볼륨군이며, 클러스터 리소스의 일ㅈ오.</li><li>관리자가 프로비저닝하거나 Storage Class를 통해 동적으로 프로비저닝 됨</li><li>일반 볼륨과의 차이점<ul><li>일반 볼륨은 Pod와 같은 라이프사이클을 가짐. 함께 생성되고 함께 내려간다는 뜻</li><li>PV는 Pod와 별개의 라이프사이클을 가지므로, Pod가 종료되어도 PV에 기록된 데이터는 삭제되지 않음</li></ul></li></ul><h3 id=pv-생성하기>PV 생성하기<a hidden class=anchor aria-hidden=true href=#pv-생성하기>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># ex) pv-definition.yaml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolume</span>
<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-vol-1</span>
<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>accessModes</span>: <span style=color:#75715e># 스토리지 볼륨 접근 방식</span>
		- <span style=color:#ae81ff>ReadWriteOnce </span>
		
	<span style=color:#f92672>capacity</span>:
		<span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span> <span style=color:#75715e># PV로 선점하고자 하는 용량</span>
		
	<span style=color:#75715e># 볼륨 타입 정의</span>
	<span style=color:#f92672>hostPath</span>:   <span style=color:#75715e># hostPath 는 해당 노드의 local directory이므로, 프로덕션에서는 권장되지 않음.</span>
		<span style=color:#f92672>path</span>: <span style=color:#ae81ff>/tmp/data</span>
		
	<span style=color:#f92672>awsElasticBlockStore</span>:
		<span style=color:#f92672>volumeID</span>: <span style=color:#ae81ff>&lt;volume-id&gt;</span>
		<span style=color:#f92672>fsType</span>: <span style=color:#ae81ff>ext4</span>
</code></pre></div><ul><li>생성: <code>kubectl create -f pv-definition.yaml</code></li><li>조회: <code>kubectl get persistentvolume</code></li></ul><p><code>accessModes</code> 유형</p><ul><li><code>ReadOnlyMany</code></li><li><code>ReadWriteOnce</code></li><li><code>ReadWriteMany</code></li></ul><h2 id=pvc-persistent-volume-claim>PVC (Persistent Volume Claim)<a hidden class=anchor aria-hidden=true href=#pvc-persistent-volume-claim>#</a></h2><ul><li>Persistent Volume (PV) 을 사용할 수 있게끔 유저가 생성하는 오브젝트</li><li>PVC가 생성되면 K8s는 이를 기반으로 PVC에서 요청한 기준에 부합하는 (그리고 용량이 여유가 있는) PV를 찾아 PVC 와 바인드(bind) 함</li><li>만일 조건에 부합하는 PV가 여러개 존재하는 경우에는 label과 selector를 써서 매칭 함</li><li>만일 최적의 매칭 조합을 찾지 못해 PVC에서 정의된 용량보다 더 큰 용량의 PV와 바인드가 되면, 남아도는 용량은 다른 PVC가 사용할 수 없게 됨 (PV와 PVC는 1:1 매칭)</li><li>이후 더 이상 가용할 수 있는 PV가 없는 상태에서 PVC가 생성되면, 매칭 가능한 PV가 추가되기 전까지는 바인딩이 pending 됨.</li><li>만일 다음과 같이 생성된 PV가 유일한 PV이고, 이어서 PVC가 생성된다면, 용량은 부합하지 않지만, 다른 선택지가 없으므로 매칭됨.</li></ul><h3 id=pvc-생성하기>PVC 생성하기<a hidden class=anchor aria-hidden=true href=#pvc-생성하기>#</a></h3><p>PV 정의 및 생성</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># ex) pv-definition.yaml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolume</span>
<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>pv-vol-1</span>
<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>accessModes</span>: 
		- <span style=color:#ae81ff>ReadWriteOnce </span>
		
	<span style=color:#f92672>capacity</span>:
		<span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi </span>
		
	<span style=color:#f92672>awsElasticBlockStore</span>:
		<span style=color:#f92672>volumeID</span>: <span style=color:#ae81ff>&lt;volume-id&gt;</span>
		<span style=color:#f92672>fsType</span>: <span style=color:#ae81ff>ext4</span>
		
	<span style=color:#f92672>persistentVolumeReclaimPolicy</span>: <span style=color:#ae81ff>Retain</span> <span style=color:#75715e># default</span>
</code></pre></div><p>PV에 매칭되는 PVC 정의</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># ex) pvc-definition.yaml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myclaim</span>
<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>accessModes</span>:
		- <span style=color:#ae81ff>ReadWriteOnce</span>
		
	<span style=color:#f92672>resources</span>:
		<span style=color:#f92672>requests</span>:
			<span style=color:#f92672>storage</span>: <span style=color:#ae81ff>500Mi</span>
</code></pre></div><ul><li>생성: <code>kubectl -f pvc-definition.yaml</code></li><li>조회: <code>kubectl get persistentvolumeclaim</code></li></ul><h3 id=pvc-바인딩-방법>PVC 바인딩 방법<a hidden class=anchor aria-hidden=true href=#pvc-바인딩-방법>#</a></h3><ul><li>PVC를 사용하고자 할 때, Pod 정의는 아래 yaml 파일과 같음.</li><li>ReplicaSet과 Deployment에서도 동일하게 적용</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># ex) pod-definition.yaml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-number-generator</span>

<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>containers</span>:
		- <span style=color:#f92672>image</span>: <span style=color:#ae81ff>alpine</span>
			<span style=color:#f92672>name</span>: <span style=color:#ae81ff>alpine</span>
			<span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>]
			<span style=color:#f92672>args</span>: [<span style=color:#e6db74>&#34;shuf -i 0-100 -n 1 &gt;&gt; /opt/number.out;&#34;</span>]
			<span style=color:#f92672>volumeMounts</span>:
				- <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/opt</span>
					<span style=color:#f92672>name</span>: <span style=color:#ae81ff>data-volume</span>
			
	<span style=color:#75715e># 볼륨 생성</span>
	<span style=color:#f92672>volumes</span>:
		- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>random-number-generator</span>
		
			<span style=color:#f92672>persistentVolumeClaim</span>:
				<span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>myclaim</span>
</code></pre></div><h3 id=pvc-삭제>PVC 삭제<a hidden class=anchor aria-hidden=true href=#pvc-삭제>#</a></h3><ul><li>삭제: <code>kubectl delete persistentvolumeclaime &lt;pvc-name></code></li></ul><p>단, PVC가 삭제되더라도 <code>persistentVolumeReclaimPolicy: Retain</code> 으로 설정되어 있기 때문에, 매뉴얼로 삭제하지 않는 한, PV는 삭제되지 않음.</p><p><code>persistentVolumeReclaimPolicy: Delete</code> 으로 설정된 경우, PVC가 삭제되면 PV도 함께 삭제됨.</p><h1 id=pv--pvc-의-라이프사이클-lifecycle-of-a-volume>PV / PVC 의 라이프사이클 (Lifecycle of a volume)<a hidden class=anchor aria-hidden=true href=#pv--pvc-의-라이프사이클-lifecycle-of-a-volume>#</a></h1><h2 id=21-프로비저닝>2.1. 프로비저닝<a hidden class=anchor aria-hidden=true href=#21-프로비저닝>#</a></h2><ul><li>정적 프로비저닝<ul><li>스토리지 기술을 명세해서 PV를 사전에 만드는 방식</li><li>리소스가 한정된 온프레미스 환경에서 사용</li><li>PV 생성 이후 PV 리소스를 사용하겠다는 PVC를 생성<ul><li>PVC에서 <code>storageClassName: ''</code> 의 설정 유의</li><li>미리 생성한 PV 안에서 가능한 PV를 바인딩하겠다는 뜻</li></ul></li><li>이후 Pod에서 PVC를 참조하면 PV를 사용할 수 있게 됨</li><li>Note:<ul><li>PVC를 설정하지 않고, Pod 생성 시 곧장 PV를 참조할 수도 있음</li><li>PVC 활용은 기존 Storage의 기술을 자세히 알지 못 하더라도 PV만 명시하면 K8s가 알아서 자원을 할당시켜주기 때문에 용이함. (따라서 권장사항)</li></ul></li></ul></li><li>동적 프로비저닝<ul><li>PV 프로비저너를 배포하고 storage class만 명시하면 동적으로 프로비저닝 함.</li><li>PVC에서 stroageClassName만 제공하면 프로비저너가 알아서 PV를 생성해주고 PVC와 연결도 해줌.</li><li>GKE를 비롯한 Cloud Service에서는 PV 프로비저너를 제공함.</li></ul></li></ul><h2 id=22-바인딩>2.2. 바인딩<a hidden class=anchor aria-hidden=true href=#22-바인딩>#</a></h2><ul><li>PV와 PVC가 연결되는 동작.</li><li>정적 프로비저닝<ul><li>PVC를 배포하면 쿠버네티스가 가능한 PV안에서 PVC를 바인딩해줌.</li><li>동적 프로비저닝의 경우는 Storage Class의 Provisioner가 PV를 동적으로 생성하고 PVC와 바인딩해줌.</li></ul></li></ul><h2 id=23-사용-사용-중>2.3. 사용, 사용 중<a hidden class=anchor aria-hidden=true href=#23-사용-사용-중>#</a></h2><ul><li>바인딩 이후로 PV는 Pod에 속해 사용 됨.</li></ul><h2 id=24-반환-reclaiming>2.4. 반환 (<strong>Reclaiming)</strong><a hidden class=anchor aria-hidden=true href=#24-반환-reclaiming>#</a></h2><ul><li>볼륨을 다 사용한 뒤, 리소스 반환 API를 사용해 PVC 오브젝트를 삭제할 수 있음.</li><li>PVC의 반환<ol><li>볼륨에서 클레임 해제</li><li>볼륨에 수행할 작업을 클러스터에 알려줌</li></ol></li><li>볼륨의 반환 정책<ul><li>Retain<ul><li>리소스를 수동으로 반환하는 정책</li><li>PVC삭제되어도 PV는 존재하기에, 관리자가 수동으로 볼륨을 반환해야 함</li></ul></li><li>Delete<ul><li>PV와 외부 인프라 등, 관련된 스토리지 자산을 모두 삭제함.</li><li>동적 프로비저닝 된 볼륨의 경우에는 Storage Class의 반환 정책을 상속받음.</li></ul></li><li>Recycle (deprecated)</li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><p><a href=https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes target=_blank>Persistent Volumes</a></p><p><a href=https://velog.io/@hoonki/%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4k8s-Persistent-Storage%eb%9e%80#%ed%94%84%eb%a1%9c%eb%b9%84%ec%a0%80%eb%8b%9d target=_blank>쿠버네티스(k8s) Persistent Storage란?</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wonyoungseo.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=https://wonyoungseo.github.io/tags/k8s/>k8s</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>