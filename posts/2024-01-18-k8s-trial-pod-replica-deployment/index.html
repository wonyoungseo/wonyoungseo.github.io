<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[KR] Kubernetes - Pod / ReplicaSet / Deployment | Wonyoung's Tech Blog</title><meta name=keywords content="kubernetes,k8s"><meta name=description content="Pod 쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.
(Pod 뿐만 아니라 다른 오브젝트도 동일)
# pod-definition.yml apiVersion: kind: metadata: spec: containers: - name: # - before the name indicates, its first item in the list image: Pod 관련 명령어
kubectl create -f [FILE NAME].yml
kubectl create -f [FILE NAME].yml --record 또는 kubectl apply -f [FILE NAME].yml
kubectl get pods
kubectl describe pod [POD NAME]
Labels, Selectors 개념  Labels and Selectors act as a filter, filtering pods for ReplicsSet Labels와 Selectors는 필터로서의 기능을 함."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://wonyoungseo.github.io/posts/2024-01-18-k8s-trial-pod-replica-deployment/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="[KR] Kubernetes - Pod / ReplicaSet / Deployment"><meta property="og:description" content="Pod 쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.
(Pod 뿐만 아니라 다른 오브젝트도 동일)
# pod-definition.yml apiVersion: kind: metadata: spec: containers: - name: # - before the name indicates, its first item in the list image: Pod 관련 명령어
kubectl create -f [FILE NAME].yml
kubectl create -f [FILE NAME].yml --record 또는 kubectl apply -f [FILE NAME].yml
kubectl get pods
kubectl describe pod [POD NAME]
Labels, Selectors 개념  Labels and Selectors act as a filter, filtering pods for ReplicsSet Labels와 Selectors는 필터로서의 기능을 함."><meta property="og:type" content="article"><meta property="og:url" content="https://wonyoungseo.github.io/posts/2024-01-18-k8s-trial-pod-replica-deployment/"><meta property="og:image" content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2024-01-18T15:12:01+09:00"><meta property="article:modified_time" content="2024-01-18T15:12:01+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[KR] Kubernetes - Pod / ReplicaSet / Deployment"><meta name=twitter:description content="Pod 쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.
(Pod 뿐만 아니라 다른 오브젝트도 동일)
# pod-definition.yml apiVersion: kind: metadata: spec: containers: - name: # - before the name indicates, its first item in the list image: Pod 관련 명령어
kubectl create -f [FILE NAME].yml
kubectl create -f [FILE NAME].yml --record 또는 kubectl apply -f [FILE NAME].yml
kubectl get pods
kubectl describe pod [POD NAME]
Labels, Selectors 개념  Labels and Selectors act as a filter, filtering pods for ReplicsSet Labels와 Selectors는 필터로서의 기능을 함."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[KR] Kubernetes - Pod / ReplicaSet / Deployment","name":"[KR] Kubernetes - Pod \/ ReplicaSet \/ Deployment","description":"Pod 쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.\n(Pod 뿐만 아니라 다른 오브젝트도 동일)\n# pod-definition.yml apiVersion: kind: metadata: spec: containers: - name: # - before the name indicates, its …","keywords":["kubernetes","k8s"],"articleBody":"Pod 쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.\n(Pod 뿐만 아니라 다른 오브젝트도 동일)\n# pod-definition.yml apiVersion: kind: metadata: spec: containers: - name: # - before the name indicates, its first item in the list image: Pod 관련 명령어\nkubectl create -f [FILE NAME].yml\nkubectl create -f [FILE NAME].yml --record 또는 kubectl apply -f [FILE NAME].yml\nkubectl get pods\nkubectl describe pod [POD NAME]\nLabels, Selectors 개념  Labels and Selectors act as a filter, filtering pods for ReplicsSet Labels와 Selectors는 필터로서의 기능을 함. ReplicaSet 뿐만 아니라 추후 다룰 Deployment, Service 등에서도 사용됨.  필터링 또는 파드를 선택하기 위한 용도로도 많이 사용 됨\n 파드에 label을 부여하고 selector를 통해 매치. 추후 파드가 수십 수백개가 되는 상태에서도 매니징을 가능케 함 type 유형 별 (파드, 레플리카셋, 디플로이먼트, 서비스 등등) app 애플리케이션 별 function 기능 별  ReplicaSet Replication Controllers (OLD)  High Availability  레플리카 Pod instance를 생성하고 관리함 Pod가 하나인 상황에서도, 만약 죽으면 새로 다시 올리는 역할을 함   Load Balancing \u0026 Scaling  multiple pod , multiple node 상황에서도 관리    Replication controller 예시\n# rc-definition.yml apiVersion: v1 # v1에서는 여전히 replication controller 지원함 kind: ReplicationController metadata: name: myapp-rc labels: app: myapp type: front-end spec: template: # Pod 생성 때 사용했던 정보를 다 가져옴  metadata: name: labels: app: type: spec: containers: - name: image: # template 과 같은 레벨에서 정의함 replicas: 3 kubectl create -f [RC FILE NAME].yml\nkubectl get replicationcontroller\nkubectl get pods\nReplicaSet 정의  Replicaiton Controller 는 deprecated 되어 대부분 ReplicaSet 으로 대체됨 생성된 복수개의 Pod 를 모니터하며, fail이 생길 경우 새 Pod를 생성함.  ReplicaSet 예시\n# replicaset-definition.yml apiVersion: apps/v1 # apps/v1 에서부터 지원 kind: ReplicaSet metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: # 갯수 replicas: 3 # ReplicaSet에서는 어떤 Pod를 쓸지 정의  selector: matchLabels: # Pod에서 명시한 label과 같은 label에서만 레플리카를 만든다 type: front-end\t # replicas와 같은 레벨에서 정의 template: # Pod 생성 때 사용했던 정보를 그대로 다 가져옴  metadata: name: myapp-pod labels: app: myapp  # labels가 위와 매칭하도록 주의!!!!!! type: front-end spec: containers: - name: nginx-container image: nginx kubectl create -f replicaset-definitnion.yml\nkubectl get replicaset\nkubectl get pods\nReplicaSet 스케일링 방식  레플리카 갯수 업데이트  kubectl replace -f replicaset-definition.yml   이미 정의된 replica의 파라미터를 수정하기  kubectl scale --replicas=6 -f replicaset-definition.yml kubectl scale —-kubekreplicas=6 replicaset(TYPE) myapp-replicaset(NAME)    주의: 정의된 내용을 수정한다고 바로 스케일링이 되는 건 아님\n변경사항을 바로 적용하고 싶다면\n kubectl edit replicaset myapp-relicaset 으로 수정(k8s가 자체로 생선한 설정파일이므로, 여기는 수정을 주의해야 함) kubectl scale replicaset myapp-replicaset —-replicas=2 바로 얄짤 없이 적용  가장 적절한 방식은 definition yaml 파일을 수정한 후, kubectl apply를 통해 적용하는 것. (정의 파일과 현상태가 sync 된 상태를 유지할 수 있음)\nDeployment  상황  여러 개의 인스턴스를 배포한 상황일 때, 인스턴스를 업그레이드 해야 한다면, 한꺼번에 업데이트 하는 것은 바람직하지 않음 → 다운 타임 등으로 유저가 영향을 받을 수 있음   Deployment 사용  Deployment는 ReplicaSet보다 더 상위의 객체이며 배포된 여러 개의 Pod 들을 seamlessly 하게 업데이트하고 끄고 닫을 수 있게 함    Deployment 정의 # deployment-definition.yml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment lables: apps: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-2container image: nginx replicas: 3 selector: matchLabels: type: front-end strategy: # strategy를 명시하지 않으면 default는 RollingUpdate 이다. type: RollingUpdate rollingUpdate: maxUnavailable: 1  kubectl create -f deployment-definition.yml kubectl get deployment kubectl explain deployment  Rollout Deployment \u0026 Rollback Rollout Rollout and Versioning\n 새로운 버전의 컨테이너가 생성되면 rollout 을 시행 deployment 생성 → rollout 실행 → 새로운 revision 생성 애플리케이션이 새 컨테이너로 업데이트되면 → 새로운 rollout 실행 → 새로운 revision 생성  Rollout history tracking 가능 Rollback도 가능    Rollout commands\n kubectl rollout status deploymnet/myapp-deployment kubectl rollout history deployment/myapp-deployment kubectl rollout history deployment  --revision=  특정 revision number를 통해 히스토리를 선택해서 조회할 수 있음.    Rollback 하는 방법 롤아웃을 취소하는 방식으로 롤백함.\n kubectl rollout undo deployment/ kubectl rollout undo deployment/ --to-revision=  특정 revision으로 롤백 -    Deployment Strategy - Recreate \u0026 RollingUpdate   Recreate Strategy\n 실행되는 인스턴스 다 내림 새 인스턴스 올림    One-by-one (Rolling update) - default strategy\n 하나씩 내리고 하나씩 올림 디폴트 설정    Recreate, RollingUpdate 업데이트하는 법\n kubectl edit -f deployment-definition.yml --record kubectl apply -f deployment-definition.yml  Blue-Green  우선 배포 하고 나서, 라우팅 트래픽을 한번에 새 버전으로 옮기는 방법 현행 deployment (blue) 가 띄워져 있는 상태로 업데이트 된 deployment (green)을 생성함. 이후 로드밸런서가 Green deployment를 가리키게 하여 업데이트를 완료함. 리소스가 Blue deployment만큼 배로 필요함.  적용하는 방법\n예시)\n service 가 blue에 연결되어 있는 상태. version: v1 이라는 label을 통해 서비스와 deployment가 연결되어 있음. version: v2 라는 label이 지정된 green을 배포함 green 이 모두 배포된 이후에는 service의 label을 version: v2 으로 변경시켜서 service가 green 과 연결되게끔 함  Canary 일정한 작은 비율을 새 버전으로 배포하고, 일정 테스트를 거치고 괜찮다 판단되면 나머지를 배포함\n적용 방법\n예시)\n service 가 blue에 연결되어 있는 상태. version: v1 이라는 label을 통해 서비스와 deployment가 연결되어 있음. old와 new 에게 공동퇴는 label을 부여하여 서비스가 new에도 연결되도록 함.  이 때, new에는 replica를 최소한의 수로 지정함. 이렇게 되면 old의 배포는 유지하며, new 는 작은 비율을 차지하게 됨 (canary)   new로 업그레이드 해도 되겠다 판단되면, primary를 업데이트하고, canary는 지움.  또는 primary를 scale down to 0 하고, canary의 replica를 기존 갯수대로 scale up 함 → 그리고 primary를 삭제    Reference  kubernetes official document Kodekloud Course  ","wordCount":"826","inLanguage":"en","datePublished":"2024-01-18T15:12:01+09:00","dateModified":"2024-01-18T15:12:01+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wonyoungseo.github.io/posts/2024-01-18-k8s-trial-pod-replica-deployment/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wonyoungseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wonyoungseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://wonyoungseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wonyoungseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wonyoungseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://wonyoungseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[KR] Kubernetes - Pod / ReplicaSet / Deployment</h1><div class=post-meta>January 18, 2024&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#pod aria-label=Pod>Pod</a></li><li><a href=#labels-selectors-%ea%b0%9c%eb%85%90 aria-label="Labels, Selectors 개념">Labels, Selectors 개념</a></li><li><a href=#replicaset aria-label=ReplicaSet>ReplicaSet</a><ul><li><a href=#replication-controllers-old aria-label="Replication Controllers (OLD)">Replication Controllers (OLD)</a></li><li><a href=#replicaset-%ec%a0%95%ec%9d%98 aria-label="ReplicaSet 정의">ReplicaSet 정의</a></li><li><a href=#replicaset-%ec%8a%a4%ec%bc%80%ec%9d%bc%eb%a7%81-%eb%b0%a9%ec%8b%9d aria-label="ReplicaSet 스케일링 방식">ReplicaSet 스케일링 방식</a></li></ul></li><li><a href=#deployment aria-label=Deployment>Deployment</a><ul><li><a href=#deployment-%ec%a0%95%ec%9d%98 aria-label="Deployment 정의">Deployment 정의</a></li><li><a href=#rollout-deployment--rollback aria-label="Rollout Deployment &amp;amp; Rollback">Rollout Deployment & Rollback</a><ul><li><a href=#rollout aria-label=Rollout>Rollout</a></li><li><a href=#rollback-%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="Rollback 하는 방법">Rollback 하는 방법</a></li><li><a href=#deployment-strategy---recreate--rollingupdate aria-label="Deployment Strategy - Recreate &amp;amp; RollingUpdate">Deployment Strategy - Recreate & RollingUpdate</a></li><li><a href=#blue-green aria-label=Blue-Green>Blue-Green</a></li><li><a href=#canary aria-label=Canary>Canary</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=pod>Pod<a hidden class=anchor aria-hidden=true href=#pod>#</a></h1><p>쿠버네티스에서 Pod를 정의하는 정의하는 yaml의 형태는 다음과 같다.</p><p>(Pod 뿐만 아니라 다른 오브젝트도 동일)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># pod-definition.yml</span>

<span style=color:#f92672>apiVersion</span>:

<span style=color:#f92672>kind</span>:

<span style=color:#f92672>metadata</span>:

<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>containers</span>:
		- <span style=color:#f92672>name</span>:   <span style=color:#75715e># - before the name indicates, its first item in the list</span>
			<span style=color:#f92672>image</span>: 
</code></pre></div><p>Pod 관련 명령어</p><p><code>kubectl create -f [FILE NAME].yml</code></p><p><code>kubectl create -f [FILE NAME].yml --record</code> 또는 <code>kubectl apply -f [FILE NAME].yml</code></p><p><code>kubectl get pods</code></p><p><code>kubectl describe pod [POD NAME]</code></p><h1 id=labels-selectors-개념>Labels, Selectors 개념<a hidden class=anchor aria-hidden=true href=#labels-selectors-개념>#</a></h1><ul><li>Labels and Selectors act as a filter, filtering pods for ReplicsSet</li><li>Labels와 Selectors는 필터로서의 기능을 함. ReplicaSet 뿐만 아니라 추후 다룰 Deployment, Service 등에서도 사용됨.</li></ul><p>필터링 또는 파드를 선택하기 위한 용도로도 많이 사용 됨</p><ul><li>파드에 label을 부여하고 selector를 통해 매치. 추후 파드가 수십 수백개가 되는 상태에서도 매니징을 가능케 함</li><li>type 유형 별 (파드, 레플리카셋, 디플로이먼트, 서비스 등등)</li><li>app 애플리케이션 별</li><li>function 기능 별</li></ul><h1 id=replicaset>ReplicaSet<a hidden class=anchor aria-hidden=true href=#replicaset>#</a></h1><h2 id=replication-controllers-old>Replication Controllers (OLD)<a hidden class=anchor aria-hidden=true href=#replication-controllers-old>#</a></h2><ul><li>High Availability<ul><li>레플리카 Pod instance를 생성하고 관리함</li><li>Pod가 하나인 상황에서도, 만약 죽으면 새로 다시 올리는 역할을 함</li></ul></li><li>Load Balancing & Scaling<ul><li>multiple pod , multiple node 상황에서도 관리</li></ul></li></ul><p>Replication controller 예시</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># rc-definition.yml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span> <span style=color:#75715e># v1에서는 여전히 replication controller 지원함</span>

<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicationController</span>

<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp-rc</span>
	<span style=color:#f92672>labels</span>:
		<span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp</span>
		<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>

<span style=color:#f92672>spec</span>: 
	<span style=color:#f92672>template</span>: 
		
		<span style=color:#75715e># Pod 생성 때 사용했던 정보를 다 가져옴 </span>
		<span style=color:#f92672>metadata</span>:
			<span style=color:#f92672>name</span>:
			<span style=color:#f92672>labels</span>:
				<span style=color:#f92672>app</span>:
				<span style=color:#f92672>type</span>:
		<span style=color:#f92672>spec</span>:
			<span style=color:#f92672>containers</span>:
				- <span style=color:#f92672>name</span>: 
					<span style=color:#f92672>image</span>: 
	
	<span style=color:#75715e># template 과 같은 레벨에서 정의함</span>
	<span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</code></pre></div><p><code>kubectl create -f [RC FILE NAME].yml</code></p><p><code>kubectl get replicationcontroller</code></p><p><code>kubectl get pods</code></p><h2 id=replicaset-정의>ReplicaSet 정의<a hidden class=anchor aria-hidden=true href=#replicaset-정의>#</a></h2><ul><li>Replicaiton Controller 는 deprecated 되어 대부분 ReplicaSet 으로 대체됨</li><li>생성된 복수개의 Pod 를 모니터하며, fail이 생길 경우 새 Pod를 생성함.</li></ul><p>ReplicaSet 예시</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># replicaset-definition.yml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span> <span style=color:#75715e># apps/v1 에서부터 지원</span>

<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicaSet</span>

<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp-replicaset</span>
	<span style=color:#f92672>labels</span>:
		<span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp</span>
		<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>

<span style=color:#f92672>spec</span>: 	
	<span style=color:#75715e># 갯수</span>
	<span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>

	<span style=color:#75715e># ReplicaSet에서는 어떤 Pod를 쓸지 정의 </span>
	<span style=color:#f92672>selector</span>: 
		
		<span style=color:#f92672>matchLabels</span>: <span style=color:#75715e># Pod에서 명시한 label과 같은 label에서만 레플리카를 만든다</span>
			<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end			</span>

	<span style=color:#75715e># replicas와 같은 레벨에서 정의</span>
	<span style=color:#f92672>template</span>: 
		<span style=color:#75715e># Pod 생성 때 사용했던 정보를 그대로 다 가져옴 </span>
		<span style=color:#f92672>metadata</span>:
			<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp-pod</span>
			<span style=color:#f92672>labels</span>:
				<span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp  </span> <span style=color:#75715e># labels가 위와 매칭하도록 주의!!!!!!</span>
				<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>
		<span style=color:#f92672>spec</span>:
			<span style=color:#f92672>containers</span>:
				- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-container</span>
					<span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</code></pre></div><p><code>kubectl create -f replicaset-definitnion.yml</code></p><p><code>kubectl get replicaset</code></p><p><code>kubectl get pods</code></p><h2 id=replicaset-스케일링-방식>ReplicaSet 스케일링 방식<a hidden class=anchor aria-hidden=true href=#replicaset-스케일링-방식>#</a></h2><ol><li>레플리카 갯수 업데이트<ul><li><code>kubectl replace -f replicaset-definition.yml</code></li></ul></li><li>이미 정의된 replica의 파라미터를 수정하기<ul><li><code>kubectl scale --replicas=6 -f replicaset-definition.yml</code></li><li><code>kubectl scale —-kubekreplicas=6 replicaset(TYPE) myapp-replicaset(NAME)</code></li></ul></li></ol><p>주의: 정의된 내용을 수정한다고 바로 스케일링이 되는 건 아님</p><p>변경사항을 바로 적용하고 싶다면</p><ul><li><code>kubectl edit replicaset myapp-relicaset</code> 으로 수정(k8s가 자체로 생선한 설정파일이므로, 여기는 수정을 주의해야 함)</li><li><code>kubectl scale replicaset myapp-replicaset —-replicas=2</code> 바로 얄짤 없이 적용</li></ul><p>가장 적절한 방식은 definition yaml 파일을 수정한 후, <code>kubectl apply</code>를 통해 적용하는 것. (정의 파일과 현상태가 sync 된 상태를 유지할 수 있음)</p><h1 id=deployment>Deployment<a hidden class=anchor aria-hidden=true href=#deployment>#</a></h1><ul><li>상황<ul><li>여러 개의 인스턴스를 배포한 상황일 때, 인스턴스를 업그레이드 해야 한다면, 한꺼번에 업데이트 하는 것은 바람직하지 않음 → 다운 타임 등으로 유저가 영향을 받을 수 있음</li></ul></li><li>Deployment 사용<ul><li>Deployment는 ReplicaSet보다 더 상위의 객체이며</li><li>배포된 여러 개의 Pod 들을 seamlessly 하게 업데이트하고 끄고 닫을 수 있게 함</li></ul></li></ul><h2 id=deployment-정의>Deployment 정의<a hidden class=anchor aria-hidden=true href=#deployment-정의>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># deployment-definition.yml</span>

<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>

<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>

<span style=color:#f92672>metadata</span>:
	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp-deployment</span>
	<span style=color:#f92672>lables</span>:
		<span style=color:#f92672>apps</span>: <span style=color:#ae81ff>myapp</span>
		<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>

<span style=color:#f92672>spec</span>:
	<span style=color:#f92672>template</span>:
		<span style=color:#f92672>metadata</span>:
			<span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp-pod</span>
			<span style=color:#f92672>labels</span>:
				<span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp</span>
				<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>

		<span style=color:#f92672>spec</span>:
			<span style=color:#f92672>containers</span>:
				- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-2container</span>
					<span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>

	<span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
	<span style=color:#f92672>selector</span>:
			<span style=color:#f92672>matchLabels</span>:
				<span style=color:#f92672>type</span>: <span style=color:#ae81ff>front-end</span>

	<span style=color:#f92672>strategy</span>:
		<span style=color:#75715e># strategy를 명시하지 않으면 default는 RollingUpdate 이다.</span>
		<span style=color:#f92672>type</span>: <span style=color:#ae81ff>RollingUpdate</span>
		<span style=color:#f92672>rollingUpdate</span>:
			<span style=color:#f92672>maxUnavailable</span>: <span style=color:#ae81ff>1</span>
</code></pre></div><ul><li><code>kubectl create -f deployment-definition.yml</code></li><li><code>kubectl get deployment</code></li><li><code>kubectl explain deployment</code></li></ul><h2 id=rollout-deployment--rollback>Rollout Deployment & Rollback<a hidden class=anchor aria-hidden=true href=#rollout-deployment--rollback>#</a></h2><h3 id=rollout>Rollout<a hidden class=anchor aria-hidden=true href=#rollout>#</a></h3><p>Rollout and Versioning</p><ul><li>새로운 버전의 컨테이너가 생성되면 rollout 을 시행</li><li>deployment 생성 → rollout 실행 → 새로운 revision 생성</li><li>애플리케이션이 새 컨테이너로 업데이트되면 → 새로운 rollout 실행 → 새로운 revision 생성<ul><li>Rollout history tracking 가능</li><li>Rollback도 가능</li></ul></li></ul><p>Rollout commands</p><ul><li><code>kubectl rollout status deploymnet/myapp-deployment</code></li><li><code>kubectl rollout history deployment/myapp-deployment</code></li><li><code>kubectl rollout history deployment &lt;deployment-name> --revision=&lt;revision-no></code><ul><li>특정 revision number를 통해 히스토리를 선택해서 조회할 수 있음.</li></ul></li></ul><h3 id=rollback-하는-방법>Rollback 하는 방법<a hidden class=anchor aria-hidden=true href=#rollback-하는-방법>#</a></h3><p>롤아웃을 취소하는 방식으로 롤백함.</p><ul><li><code>kubectl rollout undo deployment/&lt;deployment-name></code></li><li><code>kubectl rollout undo deployment/&lt;deployment-name> --to-revision=&lt;revision-no></code><ul><li>특정 revision으로 롤백 -</li></ul></li></ul><h3 id=deployment-strategy---recreate--rollingupdate>Deployment Strategy - Recreate & RollingUpdate<a hidden class=anchor aria-hidden=true href=#deployment-strategy---recreate--rollingupdate>#</a></h3><ol><li><p>Recreate Strategy</p><ul><li>실행되는 인스턴스 다 내림</li><li>새 인스턴스 올림</li></ul></li><li><p>One-by-one (Rolling update) - default strategy</p><ul><li>하나씩 내리고 하나씩 올림</li><li>디폴트 설정</li></ul></li></ol><p>Recreate, RollingUpdate 업데이트하는 법</p><ul><li><code>kubectl edit -f deployment-definition.yml --record</code></li><li><code>kubectl apply -f deployment-definition.yml</code></li></ul><h3 id=blue-green>Blue-Green<a hidden class=anchor aria-hidden=true href=#blue-green>#</a></h3><ul><li>우선 배포 하고 나서, 라우팅 트래픽을 한번에 새 버전으로 옮기는 방법</li><li>현행 deployment (blue) 가 띄워져 있는 상태로 업데이트 된 deployment (green)을 생성함.</li><li>이후 로드밸런서가 Green deployment를 가리키게 하여 업데이트를 완료함.</li><li>리소스가 Blue deployment만큼 배로 필요함.</li></ul><p><strong>적용하는 방법</strong></p><p>예시)</p><ol><li>service 가 blue에 연결되어 있는 상태. <code>version: v1</code> 이라는 label을 통해 서비스와 deployment가 연결되어 있음.</li><li><code>version: v2</code> 라는 label이 지정된 green을 배포함</li><li>green 이 모두 배포된 이후에는 service의 label을 version: v2 으로 변경시켜서 service가 green 과 연결되게끔 함</li></ol><h3 id=canary>Canary<a hidden class=anchor aria-hidden=true href=#canary>#</a></h3><p>일정한 작은 비율을 새 버전으로 배포하고, 일정 테스트를 거치고 괜찮다 판단되면 나머지를 배포함</p><p><strong>적용 방법</strong></p><p>예시)</p><ol><li>service 가 blue에 연결되어 있는 상태. version: v1 이라는 label을 통해 서비스와 deployment가 연결되어 있음.</li><li>old와 new 에게 공동퇴는 label을 부여하여 서비스가 new에도 연결되도록 함.<ol><li>이 때, new에는 replica를 최소한의 수로 지정함.</li><li>이렇게 되면 old의 배포는 유지하며, new 는 작은 비율을 차지하게 됨 (canary)</li></ol></li><li>new로 업그레이드 해도 되겠다 판단되면, primary를 업데이트하고, canary는 지움.<ul><li>또는 primary를 scale down to 0 하고, canary의 replica를 기존 갯수대로 scale up 함 → 그리고 primary를 삭제</li></ul></li></ol><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://kubernetes.io/docs/tutorials/kubernetes-basics/ target=_blank>kubernetes official document</a></li><li><a href=https://kodekloud.com/courses/kubernetes-for-the-absolute-beginners-hands-on/ target=_blank>Kodekloud Course</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wonyoungseo.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=https://wonyoungseo.github.io/tags/k8s/>k8s</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>