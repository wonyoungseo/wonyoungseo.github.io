<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[KR] Github Actions로 AWS EC2 배포 자동화 찍먹해보기 | Wonyoung's Tech Blog</title><meta name=keywords content="github,actions,깃허브,CI,CD,github actions,fastapi"><meta name=description content="지인의 선물로 받은 영화추천 웹서비스로 배우는 풀스택 을 훑어보던 중, Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 찍먹 해보기로 했다.
 0. 준비 사항 (1) 서버
 API 를 배포할 AWS EC2 인스턴스 EC2 인스턴스에 연결할 때 사용될 키페어 (.pem 파일) - RSA 유형으로 생성하여 다운로드 받자 (참고링크)  (2) GitHub 계정과 프로젝트를 관리할 repository
 기본적으로 생성되는 main 브랜치와 별개로 deploy 브랜치를 생성해놓는다."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://wonyoungseo.github.io/posts/2023-02-07-aws-ec2-deploy-github-actions/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="[KR] Github Actions로  AWS EC2 배포 자동화 찍먹해보기"><meta property="og:description" content="지인의 선물로 받은 영화추천 웹서비스로 배우는 풀스택 을 훑어보던 중, Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 찍먹 해보기로 했다.
 0. 준비 사항 (1) 서버
 API 를 배포할 AWS EC2 인스턴스 EC2 인스턴스에 연결할 때 사용될 키페어 (.pem 파일) - RSA 유형으로 생성하여 다운로드 받자 (참고링크)  (2) GitHub 계정과 프로젝트를 관리할 repository
 기본적으로 생성되는 main 브랜치와 별개로 deploy 브랜치를 생성해놓는다."><meta property="og:type" content="article"><meta property="og:url" content="https://wonyoungseo.github.io/posts/2023-02-07-aws-ec2-deploy-github-actions/"><meta property="og:image" content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2023-02-06T20:35:39+09:00"><meta property="article:modified_time" content="2023-02-06T20:35:39+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[KR] Github Actions로  AWS EC2 배포 자동화 찍먹해보기"><meta name=twitter:description content="지인의 선물로 받은 영화추천 웹서비스로 배우는 풀스택 을 훑어보던 중, Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 찍먹 해보기로 했다.
 0. 준비 사항 (1) 서버
 API 를 배포할 AWS EC2 인스턴스 EC2 인스턴스에 연결할 때 사용될 키페어 (.pem 파일) - RSA 유형으로 생성하여 다운로드 받자 (참고링크)  (2) GitHub 계정과 프로젝트를 관리할 repository
 기본적으로 생성되는 main 브랜치와 별개로 deploy 브랜치를 생성해놓는다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[KR] Github Actions로  AWS EC2 배포 자동화 찍먹해보기","name":"[KR] Github Actions로  AWS EC2 배포 자동화 찍먹해보기","description":"지인의 선물로 받은 영화추천 웹서비스로 배우는 풀스택 을 훑어보던 중, Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 찍먹 해보기로 했다.\n 0. 준비 사항 (1) 서버\n API 를 배포할 AWS EC2 인스턴스 EC2  …","keywords":["github","actions","깃허브","CI","CD","github actions","fastapi"],"articleBody":"지인의 선물로 받은 영화추천 웹서비스로 배우는 풀스택 을 훑어보던 중, Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 찍먹 해보기로 했다.\n 0. 준비 사항 (1) 서버\n API 를 배포할 AWS EC2 인스턴스 EC2 인스턴스에 연결할 때 사용될 키페어 (.pem 파일) - RSA 유형으로 생성하여 다운로드 받자 (참고링크)  (2) GitHub 계정과 프로젝트를 관리할 repository\n 기본적으로 생성되는 main 브랜치와 별개로 deploy 브랜치를 생성해놓는다. deploy 브랜치에는 서버에 배포할 코드(deploy-ready)만 올라가게 된다.  (3) API \u0026 Docker\n 해당 실습에서는 FastAPI 기반의 API 서버를 작성하였다. Docker로 컨테이너화 하여 실행한다. FastAPI 기반의 API 어플리케이션 AWS EC2 인스턴스에는 Docker가 설치해놓는다.   1. Workflow 파일 작성하기  Actions에서 자동화하고자 하는 workflow는 아래와 같은 경로에 yaml 형식으로 작성한다.  .github/workflow/{파일 이름}.yaml  변수 등록하기 ({{ secrets.변수명 }})   직접 보안과 관련된 정보 또는 hard-coding으로 간주되는 변수는 {{secrets.변수명}} 으로 입력한다\n  repository 우측 상단 Settings - Secrets and variables - Actions 탭 에서 등록하면, 추후 Github Actions workflow가 실행될 때 등록된 변수에 접근이 가능하다.\n     이번 실습에서는 다음과 같은 변수들을 등록했다 (스크린샷 참조)\n DEPLOY_HOST : 배포할 원격 서버의 주소 DEPLOY_USERNAME : 원격 서버 계정 DEPLOY_SSH_KEY : 원격 서버에 접속할 때 사용할 SSH 인증키의 값 DEPLOY_SOURCE_DIR : repository의 소스코드를 동기화할 원격 서버의 경로 DEPLOY_IMAGE_NAME : 원격 서버에서 빌드할 이미지 이름 DEPLOY_CONTAINER_NAME : 원격 서버에서 실행할 컨테이너 이름       1.1. 작성된 Workflows 파일 # .github/workflows/deploy.yaml name: Push to EC2  # workflow의 이름 on: # workflow 가 실행되게 하는 event push: # deploy 브랜치가 push (또는 merge) 될 경우 아래의 job이 실행되게 한다. branches: deploy jobs: deploy: # job의 이름 runs-on: ubuntu-latest # job이 실행되는 runner 명시 steps: # step - repository의 소스코드 내려 받기 - uses: actions/checkout@v2 # 아래 actions 설명 참조 # step - 내려 받은 소스코드를 원격 서버에 동기화 시키기 - name: rsync deployments  uses: burnett01/rsync-deployments@5.2.1 # 아래 actions 설명 참조 with: switches: -avzr --delete path: ./ remote_host: ${{ secrets.DEPLOY_HOST }} remote_user: ${{ secrets.DEPLOY_USERNAME }} remote_key: ${{ secrets.DEPLOY_SSH_KEY }} remote_path: ${{ secrets.DEPLOY_SOURCE_DIR }} # 동기화 시키고자 하는 원격 서버 내 경로 # step - 동기화된 소스코드를 가지고  # [도커 이미지 빌드 - 기존 도커 컨테이너 중단 - 새 도커 컨테이너 실행]을 수행  - name: Build, run uploaded Docker container uses: appleboy/ssh-action@master # 아래 actions 설명 참조 with: host: ${{ secrets.DEPLOY_HOST }} username: ${{ secrets.DEPLOY_USERNAME }} key: ${{ secrets.DEPLOY_SSH_KEY }} script: |cd ~ cd ${{ secrets.SOURCE_DIR }} docker build . -t ${{ secrets.DEPLOY_IMAGE_NAME }} if [ $(docker inspect -f '{{.State.Running}}' ${{ secrets.DEPLOY_CONTAINER_NAME }}) = \"true\" ]; then echo \"Stopping current running docker container ...\" \u0026\u0026 docker stop ${{ secrets.DEPLOY_CONTAINER_NAME }}; fi echo \"Running docker container based on newly built image\" docker run --name ${{ secrets.DEPLOY_CONTAINER_NAME }} --rm -d -p 8000:8000 ${{ secrets.DEPLOY_IMAGE_NAME }}  1.2. 사용된 Actions 1.2.1. checkout actions  Repository의 소스파일을 Github에서 제공하는 CI 서버로 GITHUB_WORKSPACE 내려받을 수 있게 하는 actions.  https://github.com/marketplace/actions/checkout    1.2.2. rsync actions  checkout을 통해 내려받은 소스파일을 ssh로 연결한 원격서버의 특정 경로에 배포할 수 있게 하는 actions.  https://github.com/marketplace/actions/rsync-deployments-action    1.2.3. ssh-action actions  ssh로 연결한 원격 서버에서 명령어를 실행할 수 있게 하는 actions.  https://github.com/marketplace/actions/ssh-remote-commands     2. Actions 실행 2.1. 변경 사항 Push 하기  소스코드의 변경사항을 main 브랜치에 커밋해준다 git add . git commit -m \"{커밋 메세지}\" git push origin main   2.2. main -- deploy merge 하는 PR  코드를 배포하기 위해 변경된 코드를 deploy 브랜치에 머지하는 PR을 작성하고 merge를 수행한다.    main 브랜치에서 deploy 브랜치로 merge하는 PR 작성\n     merge 실행하기\n    2.3. Actions 실행 확인하기   deploy 브랜치로의 merge가 수행되면 동시에 workflow 파일에서 정의한 push trigger가 동작되어 아래와 같이 Actions의 실행으로 이어진다. (Repository 상단의 “Actions” 탭에서 확인해보자)    (workflow가 실행되었다!)\n     (workflow가 실행되는 중이다!)\n    앞서 작성한 workflows 파일(deploy.yaml)에서 정의한 actions들이 사용되는 것을 확인할 수 있다.      workflow 파일에서 정의한 job의 step이 순차적으로 실행되었고, 해당 Actions workflow가 성공적으로 수행되었음을 확인할 수 있다.         배포된 코드 기반으로 실행 중인 API도 확인해보았다.         마무리하며 업무에서는 Github Actions를 활용한 CI/CD를 하고 있지 않기 때문에, 점심시간에 따로 경험이 있는 동료에게 물어보기도 하고 적용해서 삽질을 하기도 하면서 이런 생각이 들었다.\n 이번 찍먹 에서는 배포에만 사용해봤지만, 각 브랜치에 push 하기 이전에 진행하는 unit-test를 workflows에 포함시키면 되겠다. (이미 그렇게들 많이 쓰는 것 같다)  사실 Actions 의 예시가 여러가지가 있었지만, 배포하는 과정의 자동화에 적용하는게 내 입장에서 가장 실용적으로 다가와서 이렇게 해보긴 했다.   [새로운 이미지를 빌드 - 실행 중인 컨테이너 중단 - 새로운 이미지로 컨테이너 실행]의 프로세스가 이게 맞나...? 하는 생각이 들었다.  이 방식의 단점이 있다면 어떤 점이 있을까? 매번 이렇게 이미지를 빌드해야 하나 … ? 싶기도 하고 그렇다. Dockerfile을 보고 이미지를 빌드하는 Actions가 있지는 않을까? 바로 컨테이너만 실행할 수는 없을까? (다 하고나니 가지처럼 뻗어나가는 의문점 … ;;; ) 비슷한 다른 예시를 찾아보면 AWS S3와 AWS Code Deploy를 엮어서 사용하는 예시도 있던데, 비용이 살짝 부담되었다. 어느 방식이 “Best practice\"일까?   적절한 Actions를 marketplace 에서 찾고 적용하는 것이 핵심이겠다는 생각이 든다.   Reference  AWS EC2 생성하기 AWS EC2 키페어 파일 생성하기 GitHub Actions의 체크아웃(Checkout) 액션으로 코드 내려받기 Github Actions 사용하는 법, SSH 연결  ","wordCount":"768","inLanguage":"en","datePublished":"2023-02-06T20:35:39+09:00","dateModified":"2023-02-06T20:35:39+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wonyoungseo.github.io/posts/2023-02-07-aws-ec2-deploy-github-actions/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wonyoungseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wonyoungseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://wonyoungseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wonyoungseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wonyoungseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://wonyoungseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[KR] Github Actions로 AWS EC2 배포 자동화 찍먹해보기</h1><div class=post-meta>February 6, 2023&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#0-%ec%a4%80%eb%b9%84-%ec%82%ac%ed%95%ad aria-label="0. 준비 사항">0. 준비 사항</a></li><li><a href=#1-workflow-%ed%8c%8c%ec%9d%bc-%ec%9e%91%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="1. Workflow 파일 작성하기">1. Workflow 파일 작성하기</a><ul><li><a href=#11-%ec%9e%91%ec%84%b1%eb%90%9c-workflows-%ed%8c%8c%ec%9d%bc aria-label="1.1. 작성된 Workflows 파일">1.1. 작성된 Workflows 파일</a></li><li><a href=#12-%ec%82%ac%ec%9a%a9%eb%90%9c-actions aria-label="1.2. 사용된 Actions">1.2. 사용된 Actions</a><ul><li><a href=#121-checkout-actions aria-label="1.2.1. checkout actions">1.2.1. <code>checkout</code> actions</a></li><li><a href=#122-rsync-actions aria-label="1.2.2. rsync actions">1.2.2. <code>rsync</code> actions</a></li><li><a href=#123-ssh-action-actions aria-label="1.2.3. ssh-action actions">1.2.3. <code>ssh-action</code> actions</a></li></ul></li></ul></li><li><a href=#2-actions-%ec%8b%a4%ed%96%89 aria-label="2. Actions 실행">2. Actions 실행</a><ul><li><a href=#21-%eb%b3%80%ea%b2%bd-%ec%82%ac%ed%95%ad-push-%ed%95%98%ea%b8%b0 aria-label="2.1. 변경 사항 Push 하기">2.1. 변경 사항 Push 하기</a></li><li><a href=#22-main----deploy-merge-%ed%95%98%eb%8a%94-pr aria-label="2.2. main --&amp;gt; deploy merge 하는 PR">2.2. <code>main --> deploy</code> merge 하는 PR</a></li><li><a href=#23--actions-%ec%8b%a4%ed%96%89-%ed%99%95%ec%9d%b8%ed%95%98%ea%b8%b0 aria-label="2.3.  Actions 실행 확인하기">2.3. Actions 실행 확인하기</a></li></ul></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label=마무리하며>마무리하며</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><p>지인의 선물로 받은 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=306366957" target=_blank>영화추천 웹서비스로 배우는 풀스택</a> 을 훑어보던 중,
Gitlab 배포를 자동화하는 부분을 보고, 이번 기회에 동일한 과정을 내가 익숙한 Github으로 따라해보고 Github Actions에 대해서도 <strong>찍먹</strong> 해보기로 했다.</p><p> </p><h1 id=0-준비-사항>0. 준비 사항<a hidden class=anchor aria-hidden=true href=#0-준비-사항>#</a></h1><p>(1) 서버</p><ul><li>API 를 배포할 AWS EC2 인스턴스</li><li>EC2 인스턴스에 연결할 때 사용될 키페어 (<code>.pem</code> 파일) - RSA 유형으로 생성하여 다운로드 받자 (<a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/create-key-pairs.html target=_blank>참고링크</a>)</li></ul><p>(2) GitHub 계정과 프로젝트를 관리할 repository</p><ul><li>기본적으로 생성되는 <code>main</code> 브랜치와 별개로 <code>deploy</code> 브랜치를 생성해놓는다.</li><li><code>deploy</code> 브랜치에는 서버에 배포할 코드(deploy-ready)만 올라가게 된다.</li></ul><p>(3) API & Docker</p><ul><li>해당 실습에서는 FastAPI 기반의 API 서버를 작성하였다. Docker로 컨테이너화 하여 실행한다.</li><li>FastAPI 기반의 API 어플리케이션</li><li>AWS EC2 인스턴스에는 Docker가 설치해놓는다.</li></ul><p> </p><h1 id=1-workflow-파일-작성하기>1. Workflow 파일 작성하기<a hidden class=anchor aria-hidden=true href=#1-workflow-파일-작성하기>#</a></h1><ul><li>Actions에서 자동화하고자 하는 workflow는 아래와 같은 경로에 <code>yaml</code> 형식으로 작성한다.</li></ul><pre><code>.github/workflow/{파일 이름}.yaml
</code></pre><ul><li>변수 등록하기 (<code>{{ secrets.변수명 }}</code>)<ul><li><p>직접 보안과 관련된 정보 또는 hard-coding으로 간주되는 변수는 <code>{{secrets.변수명}}</code> 으로 입력한다</p></li><li><p>repository 우측 상단 <code>Settings -> Secrets and variables -> Actions 탭</code> 에서 등록하면, 추후 Github Actions workflow가 실행될 때 등록된 변수에 접근이 가능하다.</p><figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/1.png></center></figure></li><li><p>이번 실습에서는 다음과 같은 변수들을 등록했다 (스크린샷 참조)</p><ul><li><code>DEPLOY_HOST</code> : 배포할 원격 서버의 주소</li><li><code>DEPLOY_USERNAME</code> : 원격 서버 계정</li><li><code>DEPLOY_SSH_KEY</code> : 원격 서버에 접속할 때 사용할 SSH 인증키의 값</li><li><code>DEPLOY_SOURCE_DIR</code> : repository의 소스코드를 동기화할 원격 서버의 경로</li><li><code>DEPLOY_IMAGE_NAME</code> : 원격 서버에서 빌드할 이미지 이름</li><li><code>DEPLOY_CONTAINER_NAME</code> : 원격 서버에서 실행할 컨테이너 이름</li></ul></li></ul></li></ul><p> </p><h2 id=11-작성된-workflows-파일>1.1. 작성된 Workflows 파일<a hidden class=anchor aria-hidden=true href=#11-작성된-workflows-파일>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># .github/workflows/deploy.yaml</span>

<span style=color:#f92672>name</span>: <span style=color:#ae81ff>Push to EC2 </span> <span style=color:#75715e># workflow의 이름</span>

<span style=color:#f92672>on</span>: <span style=color:#75715e># workflow 가 실행되게 하는 event</span>
  <span style=color:#f92672>push</span>: <span style=color:#75715e># deploy 브랜치가 push (또는 merge) 될 경우 아래의 job이 실행되게 한다.</span>
    <span style=color:#f92672>branches</span>: <span style=color:#ae81ff>deploy</span>

<span style=color:#f92672>jobs</span>:
  <span style=color:#f92672>deploy</span>: <span style=color:#75715e># job의 이름</span>
    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span> <span style=color:#75715e># job이 실행되는 runner 명시</span>
    
    <span style=color:#f92672>steps</span>:
    <span style=color:#75715e># step - repository의 소스코드 내려 받기</span>
    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v2</span> <span style=color:#75715e># 아래 actions 설명 참조</span>

    <span style=color:#75715e># step - 내려 받은 소스코드를 원격 서버에 동기화 시키기</span>
    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>rsync deployments </span>
      <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>burnett01/rsync-deployments@5.2.1</span> <span style=color:#75715e># 아래 actions 설명 참조</span>
      <span style=color:#f92672>with</span>: 
        <span style=color:#f92672>switches</span>: -<span style=color:#ae81ff>avzr --delete</span>
        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>./</span>
        <span style=color:#f92672>remote_host</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_HOST }}</span>
        <span style=color:#f92672>remote_user</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_USERNAME }}</span>
        <span style=color:#f92672>remote_key</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_SSH_KEY }}</span>
        <span style=color:#f92672>remote_path</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_SOURCE_DIR }}</span> <span style=color:#75715e># 동기화 시키고자 하는 원격 서버 내 경로</span>

    <span style=color:#75715e># step - 동기화된 소스코드를 가지고 </span>
    <span style=color:#75715e># [도커 이미지 빌드 -&gt; 기존 도커 컨테이너 중단 -&gt; 새 도커 컨테이너 실행]을 수행   </span>
    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Build, run uploaded Docker container</span>
      <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>appleboy/ssh-action@master</span> <span style=color:#75715e># 아래 actions 설명 참조</span>
      <span style=color:#f92672>with</span>: 
        <span style=color:#f92672>host</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_HOST }}</span>
        <span style=color:#f92672>username</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_USERNAME }}</span>
        <span style=color:#f92672>key</span>: <span style=color:#ae81ff>${{ secrets.DEPLOY_SSH_KEY }}</span>
        <span style=color:#f92672>script</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>          cd ~
</span><span style=color:#e6db74>          cd ${{ secrets.SOURCE_DIR }}
</span><span style=color:#e6db74>          docker build . -t ${{ secrets.DEPLOY_IMAGE_NAME }}
</span><span style=color:#e6db74>          if [ $(docker inspect -f &#39;{{.State.Running}}&#39; ${{ secrets.DEPLOY_CONTAINER_NAME }}) = &#34;true&#34; ]; then echo &#34;Stopping current running docker container ...&#34; &amp;&amp; docker stop ${{ secrets.DEPLOY_CONTAINER_NAME }}; fi
</span><span style=color:#e6db74>          echo &#34;Running docker container based on newly built image&#34;
</span><span style=color:#e6db74>          docker run --name ${{ secrets.DEPLOY_CONTAINER_NAME }} --rm -d -p 8000:8000 ${{ secrets.DEPLOY_IMAGE_NAME }}</span>          
</code></pre></div><p> </p><h2 id=12-사용된-actions>1.2. 사용된 Actions<a hidden class=anchor aria-hidden=true href=#12-사용된-actions>#</a></h2><h3 id=121-checkout-actions>1.2.1. <code>checkout</code> actions<a hidden class=anchor aria-hidden=true href=#121-checkout-actions>#</a></h3><ul><li>Repository의 소스파일을 Github에서 제공하는 CI 서버로 <code>GITHUB_WORKSPACE</code> 내려받을 수 있게 하는 actions.<ul><li><a href=https://github.com/marketplace/actions/checkout>https://github.com/marketplace/actions/checkout</a></li></ul></li></ul><h3 id=122-rsync-actions>1.2.2. <code>rsync</code> actions<a hidden class=anchor aria-hidden=true href=#122-rsync-actions>#</a></h3><ul><li>checkout을 통해 내려받은 소스파일을 ssh로 연결한 원격서버의 특정 경로에 배포할 수 있게 하는 actions.<ul><li><a href=https://github.com/marketplace/actions/rsync-deployments-action>https://github.com/marketplace/actions/rsync-deployments-action</a></li></ul></li></ul><h3 id=123-ssh-action-actions>1.2.3. <code>ssh-action</code> actions<a hidden class=anchor aria-hidden=true href=#123-ssh-action-actions>#</a></h3><ul><li>ssh로 연결한 원격 서버에서 명령어를 실행할 수 있게 하는 actions.<ul><li><a href=https://github.com/marketplace/actions/ssh-remote-commands>https://github.com/marketplace/actions/ssh-remote-commands</a></li></ul></li></ul><p> </p><h1 id=2-actions-실행>2. Actions 실행<a hidden class=anchor aria-hidden=true href=#2-actions-실행>#</a></h1><h2 id=21-변경-사항-push-하기>2.1. 변경 사항 Push 하기<a hidden class=anchor aria-hidden=true href=#21-변경-사항-push-하기>#</a></h2><ul><li>소스코드의 변경사항을 <code>main</code> 브랜치에 커밋해준다<pre><code>git add .
git commit -m &quot;{커밋 메세지}&quot;
git push origin main
</code></pre></li></ul><h2 id=22-main----deploy-merge-하는-pr>2.2. <code>main --> deploy</code> merge 하는 PR<a hidden class=anchor aria-hidden=true href=#22-main----deploy-merge-하는-pr>#</a></h2><ul><li>코드를 배포하기 위해 변경된 코드를 <code>deploy</code> 브랜치에 머지하는 PR을 작성하고 merge를 수행한다.<figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/2.png alt="main 브랜치에서 deploy 브랜치로 merge하는 PR 작성"></center> <center><figcaption><p>main 브랜치에서 deploy 브랜치로 merge하는 PR 작성</p></figcaption></center></figure> <figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/3.png alt="merge 실행하기"></center> <center><figcaption><p>merge 실행하기</p></figcaption></center></figure></li></ul><h2 id=23--actions-실행-확인하기>2.3. Actions 실행 확인하기<a hidden class=anchor aria-hidden=true href=#23--actions-실행-확인하기>#</a></h2><ul><li><p><code>deploy</code> 브랜치로의 merge가 수행되면 동시에 workflow 파일에서 정의한 push trigger가 동작되어 아래와 같이 Actions의 실행으로 이어진다. (Repository 상단의 &ldquo;Actions&rdquo; 탭에서 확인해보자)<figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/4.png alt="(workflow가 실행되었다!)"></center> <center><figcaption><p>(workflow가 실행되었다!)</p></figcaption></center></figure> <figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/5.png alt="(workflow가 실행되는 중이다!)"></center> <center><figcaption><p>(workflow가 실행되는 중이다!)</p></figcaption></center></figure> </p><ul><li><p>앞서 작성한 workflows 파일(<code>deploy.yaml</code>)에서 정의한 actions들이 사용되는 것을 확인할 수 있다.<figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/6.png></center></figure> </p></li><li><p>workflow 파일에서 정의한 job의 step이 순차적으로 실행되었고, 해당 Actions workflow가 성공적으로 수행되었음을 확인할 수 있다.<figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/7.png></center></figure> <figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/8.png></center></figure></p></li><li><p>배포된 코드 기반으로 실행 중인 API도 확인해보았다.<figure><center><img src=/2023-02-07-aws-ec2-deploy-github-actions/9.png></center></figure></p></li></ul></li></ul><p> </p><h1 id=마무리하며>마무리하며<a hidden class=anchor aria-hidden=true href=#마무리하며>#</a></h1><p>업무에서는 Github Actions를 활용한 CI/CD를 하고 있지 않기 때문에, 점심시간에 따로 경험이 있는 동료에게 물어보기도 하고 적용해서 삽질을 하기도 하면서 이런 생각이 들었다.</p><ul><li>이번 <strong>찍먹</strong> 에서는 배포에만 사용해봤지만, 각 브랜치에 push 하기 이전에 진행하는 unit-test를 workflows에 포함시키면 되겠다. (이미 그렇게들 많이 쓰는 것 같다)<ul><li>사실 Actions 의 예시가 여러가지가 있었지만, 배포하는 과정의 자동화에 적용하는게 내 입장에서 가장 실용적으로 다가와서 이렇게 해보긴 했다.</li></ul></li><li>[새로운 이미지를 빌드 -> 실행 중인 컨테이너 중단 -> 새로운 이미지로 컨테이너 실행]의 프로세스가 <code>이게 맞나...?</code> 하는 생각이 들었다.<ul><li>이 방식의 단점이 있다면 어떤 점이 있을까?</li><li>매번 이렇게 이미지를 빌드해야 하나 &mldr; ? 싶기도 하고 그렇다.</li><li>Dockerfile을 보고 이미지를 빌드하는 Actions가 있지는 않을까? 바로 컨테이너만 실행할 수는 없을까? (다 하고나니 가지처럼 뻗어나가는 의문점 &mldr; ;;; )</li><li>비슷한 다른 예시를 찾아보면 AWS S3와 AWS Code Deploy를 엮어서 사용하는 예시도 있던데, 비용이 살짝 부담되었다.</li><li>어느 방식이 &ldquo;Best practice"일까?</li></ul></li><li>적절한 Actions를 marketplace 에서 찾고 적용하는 것이 핵심이겠다는 생각이 든다.</li></ul><p> 
 
 </p><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/create-key-pairs.html target=_blank>AWS EC2 생성하기</a></li><li><a href=https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/create-key-pairs.html target=_blank>AWS EC2 키페어 파일 생성하기</a></li><li><a href=https://www.daleseo.com/github-actions-checkout/ target=_blank>GitHub Actions의 체크아웃(Checkout) 액션으로 코드 내려받기</a></li><li><a href=https://bug41.tistory.com/entry/Github-Github-Actions-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EB%B2%95-SSH-%EC%97%B0%EA%B2%B0 target=_blank>Github Actions 사용하는 법, SSH 연결</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wonyoungseo.github.io/tags/github/>github</a></li><li><a href=https://wonyoungseo.github.io/tags/actions/>actions</a></li><li><a href=https://wonyoungseo.github.io/tags/%EA%B9%83%ED%97%88%EB%B8%8C/>깃허브</a></li><li><a href=https://wonyoungseo.github.io/tags/ci/>CI</a></li><li><a href=https://wonyoungseo.github.io/tags/cd/>CD</a></li><li><a href=https://wonyoungseo.github.io/tags/github-actions/>github actions</a></li><li><a href=https://wonyoungseo.github.io/tags/fastapi/>fastapi</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>