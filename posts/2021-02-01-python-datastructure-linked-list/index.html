<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[KR] 자료구조 & 알고리즘 : 링크드 리스트(Linked List) | Wonyoung's Tech Blog</title><meta name=keywords content="data structure,python"><meta name=description content="애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 링크드 리스트 : Linked List 의 개념 1.1. 링크드 리스트의 구조  데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조. 배열(Array)와의 차이점  1.2. 링크드 리스트와 배열(Array)와 차이점  배열 : 번호가 붙여진(인덱싱이 된) 칸에 원소들을 채워 넣어 관리함. 링크드 리스트: 각 원소들을 줄줄이 엮어서 관리함.  1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)  메모리라는 개념을 우리는 건물에 비유할 수 있을 것 같습니다."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://lucaseo.github.io/posts/2021-02-01-python-datastructure-linked-list/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body);></script><meta property="og:title" content="[KR] 자료구조 & 알고리즘 : 링크드 리스트(Linked List)"><meta property="og:description" content="애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 링크드 리스트 : Linked List 의 개념 1.1. 링크드 리스트의 구조  데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조. 배열(Array)와의 차이점  1.2. 링크드 리스트와 배열(Array)와 차이점  배열 : 번호가 붙여진(인덱싱이 된) 칸에 원소들을 채워 넣어 관리함. 링크드 리스트: 각 원소들을 줄줄이 엮어서 관리함.  1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)  메모리라는 개념을 우리는 건물에 비유할 수 있을 것 같습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://lucaseo.github.io/posts/2021-02-01-python-datastructure-linked-list/"><meta property="og:image" content="https://lucaseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2021-02-01T14:29:33+09:00"><meta property="article:modified_time" content="2021-02-01T14:29:33+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lucaseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[KR] 자료구조 & 알고리즘 : 링크드 리스트(Linked List)"><meta name=twitter:description content="애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 링크드 리스트 : Linked List 의 개념 1.1. 링크드 리스트의 구조  데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조. 배열(Array)와의 차이점  1.2. 링크드 리스트와 배열(Array)와 차이점  배열 : 번호가 붙여진(인덱싱이 된) 칸에 원소들을 채워 넣어 관리함. 링크드 리스트: 각 원소들을 줄줄이 엮어서 관리함.  1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)  메모리라는 개념을 우리는 건물에 비유할 수 있을 것 같습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[KR] 자료구조 \u0026 알고리즘 : 링크드 리스트(Linked List)","name":"[KR] 자료구조 \u0026 알고리즘 : 링크드 리스트(Linked List)","description":"애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)\n 1. 링크드 리스트 : Linked List 의 개념 1.1. 링크드 리스트의 구조  데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조. 배열(Array) …","keywords":["data structure","python"],"articleBody":" 애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)\n 1. 링크드 리스트 : Linked List 의 개념 1.1. 링크드 리스트의 구조  데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조. 배열(Array)와의 차이점  1.2. 링크드 리스트와 배열(Array)와 차이점  배열 : 번호가 붙여진(인덱싱이 된) 칸에 원소들을 채워 넣어 관리함. 링크드 리스트: 각 원소들을 줄줄이 엮어서 관리함.  1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)  메모리라는 개념을 우리는 건물에 비유할 수 있을 것 같습니다. 아래 예시는 배열을 사용하는 것과 linked list를 사용하는 것을 비유해서 보여주고 있습니다. 여러분의 회사가 한 건물의 일부를 임대해서 사용한다고 생각해주세요.\n    Source https://opentutorials.org/module/1335/8821    Array list의 첫 번째 회사는 모든 직원이 한곳에 모여있어야 한다는 철학이 있기 때문에 사무실이 모여있습니다. 배열은 건물을 이런 식으로 사용하는 것과 비슷합니다. 만약 회사가 성장해서 사무실이 좁아지면 더 이상 새로운 직원을 뽑을 수 없습니다. 붙어있는 공간이 없기 때문이죠. 만약 더 많은 공간이 필요하다면 더 많은 사람을 수용할 수 있는 공간을 찾아서 전체가 이사해야 합니다. Array list는 엘리먼트가 같은 곳에 모여있습니다. 만약에 3번째 자리로 가고 싶다면 한번에 3번째 방으로 갈 수 있습니다. 찾고자 하는 사무실이 몇 번째에 있는지 알고 있다면 Array list는 매우 빠릅니다.\n    Source https://opentutorials.org/module/1335/8821    Linked List의 두 번째 회사는 한 건물 내에서 한 회사가 임대한 사무실이 서로 떨어져 있습니다. 덕분에 직원이 늘어도 큰 걱정이 없습니다. 건물에서 비어있는 곳 아무데나 임대해서 들어가면 되니까요. 그런데 방문자가 사무실을 찾는 방법이 좀 비효율적입니다. 위의 그림에 있는 방문자가 3번째 사무실을 찾아가려면 우선 첫 번째 화살표의 사무실을 찾아가야 합니다. 이 사무실의 직원에게 다음 사무실이 어딘지 물어봅니다. 그럼 알려주는 사무실로 이동 한 후에 다시 물어봐서 그다음 사무실로 이동합니다. 이렇게 물어물어 사무실을 찾아가야 하는 방식이 Linked List입니다. 그래서 Linked List에서는 몇 번째 엘리먼트를 찾는 것이 느립니다.\n 1.3. 링크드 리스트 관련 용어  노드(node):  데이터가 저장되는 단위. [데이터값, 포인터]로 구성   포인터(pointer):  다음 데이터의 주소를 담고 있는 공간. 노드에서 다음 또는 이전 노드와의 연결 정보를 가지고 있는 공간.    1.4. 링크드 리스트의 장단점 장점:\n 데이터 공간을 미리 할당하지 않아도 됨. (array는 미리 데이터 공간을 할당해야 함.) 삽입과 삭제가 빠름. 따라서 삽입/삭제가 빈번히 일어날 때 많이 사용됨.  단점:\n 데이터 구조 표현에 소요되는 저장공간이 비교적 큼.  연결을 위한 별도의 데이터공간이 필요하기 때문에 저장공간 효율이 높지 않음.   데이터를 찾는 시간이 오래 걸림.  인덱싱이 된 배열와는 달리, 특정 N번째 원소에 접근하려면 링크드 리스트의 처음부터 순차적으로 원소를 훑으며 N번째 원소를 찾아가야 함.   중간에 위치한 데이터 삭제 시, 앞뒤 데이터의 연결을 다시 구현해야하는 부가적인 작업이 필요함.  2. 파이썬에서의 링크드 리스트 pt.1  링크드 리스트는 C언어에서 주요한 데이터구조이지만, 파이썬에서는 리스트 타입이 링크드 리스트의 기능을 모두 지원함.  2.1. 노드 구현하기 # 포인트가 없는 노드를 구현 class Node: def __init__(self, data): self.data = data self.next = None # 포인터가 있는 노드를 구현하기 class Node: def __init__(self, data, next=None): self.data = data self.next = next # 포인터 \u0026nbsp\n2.2. 포인터를 활용하여 노드와 노드를 연결하기 node1 = Node(1) node2 = Node(2) head = node1 # 링크드리스트의 첫 시작은 node1로 지정함. node1.next =node2 # node1의 포인터에 node2를 저장하여 연결함. print(head.data) # node1의 데이터 출력 print(node1.next.data) # node2의 데이터 출력 1 2 \u0026nbsp\n2.3. 링크드 리스트로 데이터 추가하기 class Node: def __init__(self, data, next=None): self.data = data self.next = next def add(data): node = head while node.next: node = node.next node.next = Node(data) node1 = Node(1) # 첫 번째 노드 생성 head = node1 # 첫 번째 노드를 head로 지정 for idx in range(2, 10): # 추가할 데이터를 iteration하며 추가하기 add(idx) 2.4. 링크드 리스트 데이터 접근하여 출력하기 # 한개씩 접근하기 print(head.data) # 1번째 노드 print(head.next.data) # 2번째 노드 print(head.next.next.data) # 3번째 노드 print(head.next.next.next.data) # 4번째 노드 1 2 3 4 \u0026nbsp\n# 한꺼번에 접근하기 node = head while node.next: # 노드의 데이터 순차적으로 출력 print(node.data) node = node.next print(node.data) # next가 없는 마지막 노드의 데이터 출력 1 2 3 4 5 6 7 8 9 \u0026nbsp\n2.5. 링크드 리스트의 중간 위치에 데이터 추가하기 2.5.1. 단순하게 추가해보기 # 기존의 데이터 출력하기 node = head while node.next: print(node.data) node = node.next print(node.data) 1 2 3 4 5 6 7 8 9 \u0026nbsp\nnode3_5 = Node(3.5) # 2와 3 사이에 위치할 데이터(2.5)가 담긴 노드 생성 node = head search = True while search: if node.data == 3: # 새 데이터(3.5)의 직전 데이터가 되는 노드(3)를 찾음. search = False # search 종료 else: node = node.next node_next = node.next # 노드(3)의 다음 노드(4)를 따로 빼기 node.next = node3_5 # 노드(3.5)를 노드(3)의 다음 노드로 연결 node3_5.next = node_next # 노드(4)을 노드(3.5)의 다음 노드로 연결 node = head while node.next: print(node.data) node = node.next print(node.data) 1 2 3 3.5 4 5 6 7 8 9 \u0026nbsp\n3. 파이썬에서의 링크드 리스트 pt.2 3.1. 객체지향 프로그램으로 구현해보기 class Node: def __init__(self, data, next=None): self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) def add(self, data): \"\"\" 노드를 '순차적으로' 추가함. \"\"\" if self.head == \"\": self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) def print_all(self): \"\"\" 노드를 순회하며 출력함. \"\"\" node = self.head while node: print(node.data) node = node.next 링크드 리스트의 노드 모두 순회하며 데이터를 출력하기\nlinkedlist_1 = NodeManagement(0) linkedlist_1.print_all() 0 \u0026nbsp\nfor data in range(1, 10): linkedlist_1.add(data) linkedlist_1.print_all() 0 1 2 3 4 5 6 7 8 9 \u0026nbsp\n3.2. 특정 데이터를 가진 노드 검색하기  search_node() 메서드  class Node: def __init__(self, data, next=None): self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.nodeCount = 1 def add(self, data): \"\"\" 노드를 '순차적으로' 추가함. \"\"\" if self.head == \"\": self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) self.nodeCount += 1 def print_all(self): \"\"\" 노드를 순회하며 출력함. \"\"\" node = self.head while node: print(node.data) node = node.next def search_node(self, data): \"\"\" 특정 데이터를 가진 노드 검색하기 \"\"\" node = self.head while node: if node.data == data: # 노드의 데이터가 찾고자 하는 데이터가 맞다면 그대로 리턴 return node else: node = node.next # 다음 노드로 순회 \u0026nbsp\nlinkedlist_2 = NodeManagement(0) for data in range(1, 10): linkedlist_2.add(data) linkedlist_1.print_all() linkedlist_2.search_node(4).data # 데이터가 4인 노드의 데이터 출력 0 1 2 3 4 5 6 7 8 9 4 \u0026nbsp\n3.3. 특정 인덱스의 노드 검색하기  get_node 메서드  class Node: def __init__(self, data, next=None): self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.nodeCount = 1 def add(self, data): \"\"\" 노드를 '순차적으로' 추가함. \"\"\" if self.head == \"\": self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) self.nodeCount += 1 def print_all(self): \"\"\" 노드를 순회하며 출력함. \"\"\" node = self.head while node: print(node.data) node = node.next def search_node(self, data): \"\"\" 특정 데이터를 가진 노드 검색하기 \"\"\" node = self.head while node: if node.data == data: return node else: node = node.next def get_node(self, position): \"\"\" 지정한 인덱스의 노드 가져오기 \"\"\" if position  0 or position  self.nodeCount: print(\"Error: Position not in range of length of the linked list.\") return None else: idx = 0 node = self.head while idx  position: node = node.next idx += 1 return node \u0026nbsp\nlinkedlist_3 = NodeManagement(0) for data in range(1, 10): linkedlist_3.add(data) linkedlist_1.print_all() # 전체 노드 데이터 출력 linkedlist_3.get_node(3).data # 3번째 노드의 데이터 출력  0 1 2 3 4 5 6 7 8 9 3 \u0026nbsp\n3.2. 특정 노드 삭제하기  delete ㅁㅔ서드  class Node: def __init__(self, data, next=None): self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.nodeCount = 1 def add(self, data): \"\"\" 노드를 '순차적으로' 추가함. \"\"\" if self.head == \"\": self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) self.nodeCount += 1 def print_all(self): \"\"\" 노드를 순회하며 출력함. \"\"\" node = self.head while node: print(node.data) node = node.next def search_node(self, data): \"\"\" 특정 데이터를 가진 노드 검색하기 \"\"\" node = self.head while node: if node.data == data: return node else: node = node.next def get_node(self, position): \"\"\" 지정한 인덱스의 노드 가져오기 \"\"\" if position  0 or position  self.nodeCount: print(\"Error: Position not in range of length of the linked list.\") return None else: idx = 0 node = self.head while idx  position: node = node.next idx += 1 return node def delete(self, data): \"\"\" 특정 데이터를 가진 노드 삭제 \"\"\" if self.head == \"\": print(\"No node avaible\") return if self.head.data == data: # 삭제하고자 하는 데이터가 가장 첫 번째 노드일 때 temp = self.head self.head = self.head.next del temp else: node = self.head while node.next: if node.next.data == data: # 삭제하고자 하는 데이터가 다음 노드에 있을 때 temp = node.next node.next = node.next.next # 다음 노드를 건너 뛰고, 다음다음 노드를 바로 연결 del temp pass else: node = node.next 노드를 한개(헤드) 만들어서 delete 메서드 실험하기\nlinkedlist_4 = NodeManagement(0) linkedlist_4.print_all() 0 \u0026nbsp\nlinkedlist_4.head # 헤드가 존재함 \u0026nbsp\nlinkedlist_4.delete(0) # 헤드를 삭제 linkedlist_4.head # 헤드 삭제 후에는 헤드가 출력되지 않음 linkedlist_4.print_all() # 링크드 리스트에 노드가 존재하지 않음 \u0026nbsp\n여러 노드를 추가해서 delete 메서드 실험하기\nlinkedlist_5 = NodeManagement(0) for data in range(1, 10): linkedlist_5.add(data) linkedlist_5.print_all() 0 1 2 3 4 5 6 7 8 9 \u0026nbsp\nlinkedlist_5.delete(6) # 노드 한개를 삭제함 linkedlist_5.print_all() 0 1 2 3 4 5 7 8 9 \u0026nbsp\nlinkedlist_5.delete(3) linkedlist_5.print_all() 0 1 2 4 5 7 8 9 \u0026nbsp\n3.3. 새 노드 중간에 삽입하기  insert 메서드  class Node: def __init__(self, data, next=None): self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.nodeCount = 1 def add(self, data): \"\"\" 노드를 '순차적으로' 추가함. \"\"\" if self.head == \"\": self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) self.nodeCount += 1 def print_all(self): \"\"\" 노드를 순회하며 출력함. \"\"\" node = self.head while node: print(node.data) node = node.next def search_node(self, data): \"\"\" 특정 데이터를 가진 노드 검색하기 \"\"\" node = self.head while node: if node.data == data: return node else: node = node.next def get_node(self, position): \"\"\" 지정한 인덱스의 노드 가져오기 \"\"\" if position  0 or position  self.nodeCount: print(\"Error: Position not in range of length of the linked list.\") return None else: idx = 0 node = self.head while idx  position: node = node.next idx += 1 return node def delete(self, data): \"\"\" 특정 데이터를 가진 노드 삭제 \"\"\" if self.head == \"\": print(\"No node avaible\") return if self.head.data == data: # 삭제하고자 하는 데이터가 가장 첫 번째 노드일 때 temp = self.head self.head = self.head.next del temp else: node = self.head while node.next: if node.next.data == data: # 삭제하고자 하는 데이터가 다음 노드에 있을 때 temp = node.next node.next = node.next.next # 다음 노드를 건너 뛰고, 다음다음 노드를 바로 연결 del temp pass else: node = node.next def insert(self, data, position_index): \"\"\" 지정한 위치에 데이터 노드 삽입하기 \"\"\" if position_index == 0: # head 위치에 삽입하기 temp = self.head self.head = Node(data) self.head.next = temp self.nodeCount += 1 elif position_index  self.nodeCount + 1: print(\"Error: Insert index exceeds the length of linked list\") return else: node = self.head search_index = 0 search_status = True while search_status: search_index += 1 if search_index == position_index: search_status = False insert_node = Node(data) node_next = node.next node.next = insert_node insert_node.next = node_next self.nodeCount += 1 else: node = node.next linkedlist_6 = NodeManagement(0) for data in range(1, 10): linkedlist_6.add(data) linkedlist_6.print_all() # 노드 순회하며 데이터 출력하기 linkedlist_6.nodeCount # 노드 개수 출력하기 0 1 2 3 4 5 6 7 8 9 10 \u0026nbsp\nlinkedlist_6.insert(17, 7) # 17이라는 데이터를 7번째 인덱스에 넣기 linkedlist_6.print_all() linkedlist_6.nodeCount # 노드 삽입 후 노드 개수 출력 0 1 2 3 4 5 6 17 7 8 9 11 \u0026nbsp\n4. 링크드 리스트의 개선된 타입 4.1. 더블 링크드 리스트 : Doubly-Linked List  링크드 리스트의 단점을 보완하기 위해 등장함.  4.1.1. 기본 구조  양방향으로 연결되어 있어, 노드 탐색이 양쪽으로 모두 가능한 구조 즉, 다음 노드를 가리키는 포인터(next) 뿐만 아니라, 이전 노드를 가리키는 포인터(prev)도 존재함.  \u0026nbsp\n4.1.2. 더블 링크드 리스트의 장단점 장점:\n 양방향으로 탐색이 가능함.  단점:\n 이전 노드를 가리키는 포인터가 추가되기 때문에 메모리 사용량이 늘어남. 삽입/삭제 연산에 있어, 앞/뒤 연결링크를 조정해줘야 하기 때문에 구조가 복잡해짐.  \u0026nbsp\n4.1.2. 파이썬으로 구현한 더블 링크드 리스트  더블 링크드 리스트의 노드는 이전 노드와 다음 노드를 가리키는 포인터를 포함하는 것이 핵심.  class Node: def __init__(self, data, prev=None, next=None): self.prev = prev self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.tail = self.head def add(self, data): if self.head == None: self.head = Node(data) self.tail = self.head else: node = self.head while node.next: node = node.next new = Node(data) node.next = new new.prev = node self.tail = new def print_all(self): node = self.head while node: print(node.data) node = node.next \u0026nbsp\ndouble_linked_list = NodeManagement(0) for data in range(1, 10): double_linked_list.add(data) double_linked_list.print_all() 0 1 2 3 4 5 6 7 8 9 \u0026nbsp\n4.2. 더블 링크드 리스트의 검색과 삽입 4.2.1. 특정 노드 이전에 새로운 노드 삽입하기 class Node: def __init__(self, data, prev=None, next=None): self.prev = prev self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.tail = self.head def add(self, data): if self.head == None: self.head = Node(data) self.tail = self.head else: node = self.head while node.next: node = node.next new = Node(data) node.next = new new.prev = node self.tail = new def print_all(self): node = self.head while node: print(node.data) node = node.next def search_from_head(self, data): if self.head == None: return None node = self.head while node: if node.data == data: return node else: node = node.next return None def search_from_tail(self, data): if self.head == None: return None node = self.tail while node: if node.data == data: return node else: node = node.prev return None def insert_before(self, data, prev_data): if self.head == None: self.head = Node(data) return None else: node = self.tail while node.data != prev_data: node = node.prev if node == None: return None new_node = Node(data) prev_new = node.prev prev_new.next = new_node new_node.prev = prev_new new_node.next = node node.prev = new_node return None \u0026nbsp\ndouble_linked_list = NodeManagement(0) for data in range(1, 10): double_linked_list.add(data) double_linked_list.print_all() 0 1 2 3 4 5 6 7 8 9 \u0026nbsp\n# 뒤에서부터 찾기 node_3 = double_linked_list.search_from_tail(3) node_3.data 3 \u0026nbsp\n# 앞에서부터 찾기 node_8 = double_linked_list.search_from_head(8) node_8.data 8 \u0026nbsp\ndouble_linked_list.insert_before(4.5, 5) double_linked_list.print_all() 0 1 2 3 4 4.5 5 6 7 8 9 \u0026nbsp\nnode_4_5 = double_linked_list.search_from_tail(4.5) node_4_5.data 4.5 \u0026nbsp\n4.2.2. 특정 노드 이후에 새로운 노드 삽입하기 class Node: def __init__(self, data, prev=None, next=None): self.prev = prev self.data = data self.next = next class NodeManagement: def __init__(self, data): self.head = Node(data) self.tail = self.head def add(self, data): if self.head == None: self.head = Node(data) self.tail = self.head else: node = self.head while node.next: node = node.next new = Node(data) node.next = new new.prev = node self.tail = new def print_all(self): node = self.head while node: print(node.data) node = node.next def search_from_head(self, data): if self.head == None: return None node = self.head while node: if node.data == data: return node else: node = node.next return None def search_from_tail(self, data): if self.head == None: return None node = self.tail while node: if node.data == data: return node else: node = node.prev return None def insert_before(self, data, prev_data): if self.head == None: self.head = Node(data) return None else: node = self.tail while node.data != prev_data: node = node.prev if node == None: return None new_node = Node(data) prev_new = node.prev prev_new.next = new_node new_node.next = node return None def insert_after(self, data, next_data): if self.head == None: self.head = Node(data) return None else: node = self.head while node.data != next_data: node = node.next if node == None: return None new_node = Node(data) next_new = node.next new_node.next = next_new new_node.prev = node if new_node.next == None: self.tail = new_node else: node.next = new_node return True double_linked_list_2 = NodeManagement(0) for data in range(1, 10): double_linked_list_2.add(data) double_linked_list_2.print_all() 0 1 2 3 4 5 6 7 8 9 \u0026nbsp\ndouble_linked_list_2.insert_after(2.5, 2) True \u0026nbsp\ndouble_linked_list_2.print_all() 0 1 2 2.5 3 4 5 6 7 8 9 5. 정리해보기  배열 리스트는 일정한 공간을 할당 후, 그 공간 안에서 물리적인 순서를 가지는 자료구조이다. 반대로 링크드 리스트(연결리스트)는 데이터를 담고 있는 노드들의 논리적인 순서를 위한 자료구조이다. 논리적인 구조는 이전/다음 노드를 가리키는 포인터를 통해 정의한다. 링크드 리스트는 처음부터 특정 공간을 할당하지 않아 메모리 활용도가 유연하고, 메모리 낭비를 막을 수 있다. 삽입과 삭제가 빠르다. 구현 작업은 다소 복잡할 지 모르나, 구현 후 실행은 간단하다. 하지만 포인터라는 요소까지 포함하여야 하기 때문에 비교적 더 큰 공간을 잡아먹는다. 또한 배열와는 달리, 순차적으로 노드를 훑으며 노드를 찾아가야 하기 때문에 시간이 좀 더 걸린다. 단순한 링크드 리스트는 한방향으로만 노드를 탐색하기 때문에 비효율적일 수 있다. 양방향 링크드 리스트는 앞/뒤에서부터 동시에 노드를 탐색하기 때문에 단순 링크드 리스트의 단점을 보완할 수 있다.  6. Reference  Fastcampus 알고리즘 / 기술면접 강의 프로그래머스 프로그램밍 강의 어서와! 자료구조는 처음이지? 생활코딩  ","wordCount":"2687","inLanguage":"en","datePublished":"2021-02-01T14:29:33+09:00","dateModified":"2021-02-01T14:29:33+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lucaseo.github.io/posts/2021-02-01-python-datastructure-linked-list/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://lucaseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://lucaseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://lucaseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://lucaseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://lucaseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://lucaseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[KR] 자료구조 & 알고리즘 : 링크드 리스트(Linked List)</h1><div class=post-meta>February 1, 2021&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#1-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8--linked-list-%ec%9d%98-%ea%b0%9c%eb%85%90 aria-label="1. 링크드 리스트 : Linked List 의 개념">1. 링크드 리스트 : Linked List 의 개념</a><ul><li><a href=#11-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="1.1. 링크드 리스트의 구조">1.1. 링크드 리스트의 구조</a></li><li><a href=#12-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%99%80-%eb%b0%b0%ec%97%b4array%ec%99%80-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="1.2. 링크드 리스트와 배열(Array)와 차이점">1.2. 링크드 리스트와 배열(Array)와 차이점</a><ul><li><a href=#121-%eb%b0%b0%ec%97%b4%ea%b3%bc-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%eb%b9%84%ec%9c%a0%ec%a0%81-%eb%b9%84%ea%b5%90-%ec%b6%9c%ec%b2%98-%ec%83%9d%ed%99%9c%ec%bd%94%eb%94%a9 aria-label="1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)">1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)</a></li></ul></li><li><a href=#13-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8-%ea%b4%80%eb%a0%a8-%ec%9a%a9%ec%96%b4 aria-label="1.3. 링크드 리스트 관련 용어">1.3. 링크드 리스트 관련 용어</a></li><li><a href=#14-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%9e%a5%eb%8b%a8%ec%a0%90 aria-label="1.4. 링크드 리스트의 장단점">1.4. 링크드 리스트의 장단점</a></li></ul></li><li><a href=#2-%ed%8c%8c%ec%9d%b4%ec%8d%ac%ec%97%90%ec%84%9c%ec%9d%98-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8-pt1 aria-label="2. 파이썬에서의 링크드 리스트 pt.1">2. 파이썬에서의 링크드 리스트 pt.1</a><ul><li><a href=#21-%eb%85%b8%eb%93%9c-%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0 aria-label="2.1. 노드 구현하기">2.1. 노드 구현하기</a></li><li><a href=#22-%ed%8f%ac%ec%9d%b8%ed%84%b0%eb%a5%bc-%ed%99%9c%ec%9a%a9%ed%95%98%ec%97%ac-%eb%85%b8%eb%93%9c%ec%99%80-%eb%85%b8%eb%93%9c%eb%a5%bc-%ec%97%b0%ea%b2%b0%ed%95%98%ea%b8%b0 aria-label="2.2. 포인터를 활용하여 노드와 노드를 연결하기">2.2. 포인터를 활용하여 노드와 노드를 연결하기</a></li><li><a href=#23-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%eb%a1%9c-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%b6%94%ea%b0%80%ed%95%98%ea%b8%b0 aria-label="2.3. 링크드 리스트로 데이터 추가하기">2.3. 링크드 리스트로 데이터 추가하기</a></li><li><a href=#24-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a0%91%ea%b7%bc%ed%95%98%ec%97%ac-%ec%b6%9c%eb%a0%a5%ed%95%98%ea%b8%b0 aria-label="2.4. 링크드 리스트 데이터 접근하여 출력하기">2.4. 링크드 리스트 데이터 접근하여 출력하기</a></li><li><a href=#25-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%a4%91%ea%b0%84-%ec%9c%84%ec%b9%98%ec%97%90-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%b6%94%ea%b0%80%ed%95%98%ea%b8%b0 aria-label="2.5. 링크드 리스트의 중간 위치에 데이터 추가하기">2.5. 링크드 리스트의 중간 위치에 데이터 추가하기</a><ul><li><a href=#251-%eb%8b%a8%ec%88%9c%ed%95%98%ea%b2%8c-%ec%b6%94%ea%b0%80%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="2.5.1. 단순하게 추가해보기">2.5.1. 단순하게 추가해보기</a></li></ul></li></ul></li><li><a href=#3-%ed%8c%8c%ec%9d%b4%ec%8d%ac%ec%97%90%ec%84%9c%ec%9d%98-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8-pt2 aria-label="3. 파이썬에서의 링크드 리스트 pt.2">3. 파이썬에서의 링크드 리스트 pt.2</a><ul><li><a href=#31-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ed%98%84%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="3.1. 객체지향 프로그램으로 구현해보기">3.1. 객체지향 프로그램으로 구현해보기</a></li><li><a href=#32-%ed%8a%b9%ec%a0%95-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc-%ea%b0%80%ec%a7%84-%eb%85%b8%eb%93%9c-%ea%b2%80%ec%83%89%ed%95%98%ea%b8%b0 aria-label="3.2. 특정 데이터를 가진 노드 검색하기">3.2. 특정 데이터를 가진 노드 검색하기</a></li><li><a href=#33-%ed%8a%b9%ec%a0%95-%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%9d%98-%eb%85%b8%eb%93%9c-%ea%b2%80%ec%83%89%ed%95%98%ea%b8%b0 aria-label="3.3. 특정 인덱스의 노드 검색하기">3.3. 특정 인덱스의 노드 검색하기</a></li><li><a href=#32-%ed%8a%b9%ec%a0%95-%eb%85%b8%eb%93%9c-%ec%82%ad%ec%a0%9c%ed%95%98%ea%b8%b0 aria-label="3.2. 특정 노드 삭제하기">3.2. 특정 노드 삭제하기</a></li><li><a href=#33-%ec%83%88-%eb%85%b8%eb%93%9c-%ec%a4%91%ea%b0%84%ec%97%90-%ec%82%bd%ec%9e%85%ed%95%98%ea%b8%b0 aria-label="3.3. 새 노드 중간에 삽입하기">3.3. 새 노드 중간에 삽입하기</a></li></ul></li><li><a href=#4-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ea%b0%9c%ec%84%a0%eb%90%9c-%ed%83%80%ec%9e%85 aria-label="4. 링크드 리스트의 개선된 타입">4. 링크드 리스트의 개선된 타입</a><ul><li><a href=#41-%eb%8d%94%eb%b8%94-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8--doubly-linked-list aria-label="4.1. 더블 링크드 리스트 : Doubly-Linked List">4.1. 더블 링크드 리스트 : Doubly-Linked List</a><ul><li><a href=#411-%ea%b8%b0%eb%b3%b8-%ea%b5%ac%ec%a1%b0 aria-label="4.1.1. 기본 구조">4.1.1. 기본 구조</a></li><li><a href=#412-%eb%8d%94%eb%b8%94-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%9e%a5%eb%8b%a8%ec%a0%90 aria-label="4.1.2. 더블 링크드 리스트의 장단점">4.1.2. 더블 링크드 리스트의 장단점</a></li><li><a href=#412-%ed%8c%8c%ec%9d%b4%ec%8d%ac%ec%9c%bc%eb%a1%9c-%ea%b5%ac%ed%98%84%ed%95%9c-%eb%8d%94%eb%b8%94-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8 aria-label="4.1.2. 파이썬으로 구현한 더블 링크드 리스트">4.1.2. 파이썬으로 구현한 더블 링크드 리스트</a></li></ul></li><li><a href=#42-%eb%8d%94%eb%b8%94-%eb%a7%81%ed%81%ac%eb%93%9c-%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ea%b2%80%ec%83%89%ea%b3%bc-%ec%82%bd%ec%9e%85 aria-label="4.2. 더블 링크드 리스트의 검색과 삽입">4.2. 더블 링크드 리스트의 검색과 삽입</a><ul><li><a href=#421-%ed%8a%b9%ec%a0%95-%eb%85%b8%eb%93%9c-%ec%9d%b4%ec%a0%84%ec%97%90-%ec%83%88%eb%a1%9c%ec%9a%b4-%eb%85%b8%eb%93%9c-%ec%82%bd%ec%9e%85%ed%95%98%ea%b8%b0 aria-label="4.2.1. 특정 노드 이전에 새로운 노드 삽입하기">4.2.1. 특정 노드 이전에 새로운 노드 삽입하기</a></li><li><a href=#422-%ed%8a%b9%ec%a0%95-%eb%85%b8%eb%93%9c-%ec%9d%b4%ed%9b%84%ec%97%90-%ec%83%88%eb%a1%9c%ec%9a%b4-%eb%85%b8%eb%93%9c-%ec%82%bd%ec%9e%85%ed%95%98%ea%b8%b0 aria-label="4.2.2. 특정 노드 이후에 새로운 노드 삽입하기">4.2.2. 특정 노드 이후에 새로운 노드 삽입하기</a></li></ul></li></ul></li><li><a href=#5-%ec%a0%95%eb%a6%ac%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="5. 정리해보기">5. 정리해보기</a></li><li><a href=#6-reference aria-label="6. Reference">6. Reference</a></li></ul></div></details></div><div class=post-content><blockquote><p><em>애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)</em></p></blockquote><h1 id=1-링크드-리스트--linked-list-의-개념>1. 링크드 리스트 : Linked List 의 개념<a hidden class=anchor aria-hidden=true href=#1-링크드-리스트--linked-list-의-개념>#</a></h1><h2 id=11-링크드-리스트의-구조>1.1. 링크드 리스트의 구조<a hidden class=anchor aria-hidden=true href=#11-링크드-리스트의-구조>#</a></h2><p><img src=https://cdn.programiz.com/sites/tutorial2program/files/linked-list-concept.png#center alt title="Source https://www.programiz.com/dsa/linked-list"></p><ul><li>데이터와 데이터 사이를 화살표로 연결하여 관리하는 데이터 구조.</li><li>배열(Array)와의 차이점</li></ul><h2 id=12-링크드-리스트와-배열array와-차이점>1.2. 링크드 리스트와 배열(Array)와 차이점<a hidden class=anchor aria-hidden=true href=#12-링크드-리스트와-배열array와-차이점>#</a></h2><ul><li>배열 : 번호가 붙여진(인덱싱이 된) 칸에 원소들을 채워 넣어 관리함.</li><li>링크드 리스트: 각 원소들을 줄줄이 엮어서 관리함.</li></ul><h3 id=121-배열과-링크드-리스트의-비유적-비교-출처-생활코딩>1.2.1. 배열과 링크드 리스트의 비유적 비교 (출처: 생활코딩)<a hidden class=anchor aria-hidden=true href=#121-배열과-링크드-리스트의-비유적-비교-출처-생활코딩>#</a></h3><blockquote><p>메모리라는 개념을 우리는 건물에 비유할 수 있을 것 같습니다. 아래 예시는 배열을 사용하는 것과 linked list를 사용하는 것을 비유해서 보여주고 있습니다. 여러분의 회사가 한 건물의 일부를 임대해서 사용한다고 생각해주세요.</p></blockquote><figure><center><img src=/2021-02-01-python-datastructure-linked-list/array.jpeg></center> <center><figcaption>Source https://opentutorials.org/module/1335/8821</figcaption></center></figure><blockquote><p>Array list의 첫 번째 회사는 모든 직원이 한곳에 모여있어야 한다는 철학이 있기 때문에 사무실이 모여있습니다. 배열은 건물을 이런 식으로 사용하는 것과 비슷합니다. 만약 <strong>회사가 성장해서 사무실이 좁아지면 더 이상 새로운 직원을 뽑을 수 없습니다. 붙어있는 공간이 없기 때문이죠. 만약 더 많은 공간이 필요하다면 더 많은 사람을 수용할 수 있는 공간을 찾아서 전체가 이사해야 합니다.</strong> Array list는 엘리먼트가 같은 곳에 모여있습니다. 만약에 3번째 자리로 가고 싶다면 한번에 3번째 방으로 갈 수 있습니다. 찾고자 하는 사무실이 몇 번째에 있는지 알고 있다면 Array list는 매우 빠릅니다.</p></blockquote><figure><center><img src=/2021-02-01-python-datastructure-linked-list/linkedlist.jpeg></center> <center><figcaption>Source https://opentutorials.org/module/1335/8821</figcaption></center></figure><blockquote><p>Linked List의 두 번째 회사는 한 건물 내에서 한 회사가 임대한 사무실이 서로 떨어져 있습니다. 덕분에 직원이 늘어도 큰 걱정이 없습니다. <strong>건물에서 비어있는 곳 아무데나 임대해서 들어가면 되니까요.</strong> 그런데 방문자가 사무실을 찾는 방법이 좀 비효율적입니다. 위의 그림에 있는 방문자가 3번째 사무실을 찾아가려면 우선 첫 번째 화살표의 사무실을 찾아가야 합니다. 이 사무실의 직원에게 다음 사무실이 어딘지 물어봅니다. 그럼 알려주는 사무실로 이동 한 후에 다시 물어봐서 그다음 사무실로 이동합니다. 이렇게 물어물어 사무실을 찾아가야 하는 방식이 Linked List입니다. 그래서 Linked List에서는 몇 번째 엘리먼트를 찾는 것이 느립니다.</p></blockquote><h2 id=13-링크드-리스트-관련-용어>1.3. 링크드 리스트 관련 용어<a hidden class=anchor aria-hidden=true href=#13-링크드-리스트-관련-용어>#</a></h2><ul><li>노드(node):<ul><li>데이터가 저장되는 단위.</li><li>[데이터값, 포인터]로 구성</li></ul></li><li>포인터(pointer):<ul><li>다음 데이터의 주소를 담고 있는 공간.</li><li>노드에서 다음 또는 이전 노드와의 연결 정보를 가지고 있는 공간.</li></ul></li></ul><h2 id=14-링크드-리스트의-장단점>1.4. 링크드 리스트의 장단점<a hidden class=anchor aria-hidden=true href=#14-링크드-리스트의-장단점>#</a></h2><p>장점:</p><ul><li>데이터 공간을 미리 할당하지 않아도 됨. (array는 미리 데이터 공간을 할당해야 함.)</li><li>삽입과 삭제가 빠름. 따라서 삽입/삭제가 빈번히 일어날 때 많이 사용됨.</li></ul><p>단점:</p><ul><li>데이터 구조 표현에 소요되는 저장공간이 비교적 큼.<ul><li>연결을 위한 별도의 데이터공간이 필요하기 때문에 저장공간 효율이 높지 않음.</li></ul></li><li>데이터를 찾는 시간이 오래 걸림.<ul><li>인덱싱이 된 배열와는 달리, 특정 N번째 원소에 접근하려면 링크드 리스트의 처음부터 순차적으로 원소를 훑으며 N번째 원소를 찾아가야 함.</li></ul></li><li>중간에 위치한 데이터 삭제 시, 앞뒤 데이터의 연결을 다시 구현해야하는 부가적인 작업이 필요함.</li></ul><h1 id=2-파이썬에서의-링크드-리스트-pt1>2. 파이썬에서의 링크드 리스트 pt.1<a hidden class=anchor aria-hidden=true href=#2-파이썬에서의-링크드-리스트-pt1>#</a></h1><ul><li>링크드 리스트는 C언어에서 주요한 데이터구조이지만, 파이썬에서는 리스트 타입이 링크드 리스트의 기능을 모두 지원함.</li></ul><h2 id=21-노드-구현하기>2.1. 노드 구현하기<a hidden class=anchor aria-hidden=true href=#21-노드-구현하기>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 포인트가 없는 노드를 구현</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> None
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 포인터가 있는 노드를 구현하기</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next  <span style=color:#75715e># 포인터</span>
</code></pre></div><p>&nbsp</p><h2 id=22-포인터를-활용하여-노드와-노드를-연결하기>2.2. 포인터를 활용하여 노드와 노드를 연결하기<a hidden class=anchor aria-hidden=true href=#22-포인터를-활용하여-노드와-노드를-연결하기>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node1 <span style=color:#f92672>=</span> Node(<span style=color:#ae81ff>1</span>)
node2 <span style=color:#f92672>=</span> Node(<span style=color:#ae81ff>2</span>)
head <span style=color:#f92672>=</span> node1 <span style=color:#75715e># 링크드리스트의 첫 시작은 node1로 지정함.</span>
node1<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span>node2 <span style=color:#75715e># node1의 포인터에 node2를 저장하여 연결함.</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(head<span style=color:#f92672>.</span>data) <span style=color:#75715e># node1의 데이터 출력</span>
<span style=color:#66d9ef>print</span>(node1<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data)  <span style=color:#75715e># node2의 데이터 출력</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    1
    2
</code></pre><p>&nbsp</p><h2 id=23-링크드-리스트로-데이터-추가하기>2.3. 링크드 리스트로 데이터 추가하기<a hidden class=anchor aria-hidden=true href=#23-링크드-리스트로-데이터-추가하기>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
        
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(data):
    node <span style=color:#f92672>=</span> head
    <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
        node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
    node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node1 <span style=color:#f92672>=</span> Node(<span style=color:#ae81ff>1</span>) <span style=color:#75715e># 첫 번째 노드 생성</span>
head <span style=color:#f92672>=</span> node1 <span style=color:#75715e># 첫 번째 노드를 head로 지정</span>
<span style=color:#66d9ef>for</span> idx <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>10</span>): <span style=color:#75715e># 추가할 데이터를 iteration하며 추가하기</span>
    add(idx)
</code></pre></div><h2 id=24-링크드-리스트-데이터-접근하여-출력하기>2.4. 링크드 리스트 데이터 접근하여 출력하기<a hidden class=anchor aria-hidden=true href=#24-링크드-리스트-데이터-접근하여-출력하기>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 한개씩 접근하기</span>
<span style=color:#66d9ef>print</span>(head<span style=color:#f92672>.</span>data) <span style=color:#75715e># 1번째 노드</span>
<span style=color:#66d9ef>print</span>(head<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data) <span style=color:#75715e># 2번째 노드</span>
<span style=color:#66d9ef>print</span>(head<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data) <span style=color:#75715e># 3번째 노드</span>
<span style=color:#66d9ef>print</span>(head<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data) <span style=color:#75715e># 4번째 노드</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    1
    2
    3
    4
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 한꺼번에 접근하기</span>
node <span style=color:#f92672>=</span> head
<span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next: <span style=color:#75715e># 노드의 데이터 순차적으로 출력</span>
    <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
<span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)   <span style=color:#75715e># next가 없는 마지막 노드의 데이터 출력</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><h2 id=25-링크드-리스트의-중간-위치에-데이터-추가하기>2.5. 링크드 리스트의 중간 위치에 데이터 추가하기<a hidden class=anchor aria-hidden=true href=#25-링크드-리스트의-중간-위치에-데이터-추가하기>#</a></h2><p><img src=https://www.fun-coding.org/00_Images/linkedlistadd.png#center alt title="Source: wikipedia, https://en.wikipedia.org/wiki/Linked_list"></p><h3 id=251-단순하게-추가해보기>2.5.1. 단순하게 추가해보기<a hidden class=anchor aria-hidden=true href=#251-단순하게-추가해보기>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 기존의 데이터 출력하기</span>

node <span style=color:#f92672>=</span> head
<span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
    <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
<span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node3_5 <span style=color:#f92672>=</span> Node(<span style=color:#ae81ff>3.5</span>) <span style=color:#75715e># 2와 3 사이에 위치할 데이터(2.5)가 담긴 노드 생성</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node <span style=color:#f92672>=</span> head
search <span style=color:#f92672>=</span> True 
<span style=color:#66d9ef>while</span> search:
    <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>: <span style=color:#75715e># 새 데이터(3.5)의 직전 데이터가 되는 노드(3)를 찾음.</span>
        search <span style=color:#f92672>=</span> False <span style=color:#75715e># search 종료</span>
    <span style=color:#66d9ef>else</span>:
        node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
        
node_next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next <span style=color:#75715e># 노드(3)의 다음 노드(4)를 따로 빼기</span>
node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node3_5 <span style=color:#75715e># 노드(3.5)를 노드(3)의 다음 노드로 연결</span>
node3_5<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node_next <span style=color:#75715e># 노드(4)을 노드(3.5)의 다음 노드로 연결</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node <span style=color:#f92672>=</span> head
<span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
    <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
<span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    1
    2
    3
    3.5
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><h1 id=3-파이썬에서의-링크드-리스트-pt2>3. 파이썬에서의 링크드 리스트 pt.2<a hidden class=anchor aria-hidden=true href=#3-파이썬에서의-링크드-리스트-pt2>#</a></h1><h2 id=31-객체지향-프로그램으로-구현해보기>3.1. 객체지향 프로그램으로 구현해보기<a hidden class=anchor aria-hidden=true href=#31-객체지향-프로그램으로-구현해보기>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 &#39;순차적으로&#39; 추가함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
            
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 순회하며 출력함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next    
</code></pre></div><p><strong>링크드 리스트의 노드 모두 순회하며 데이터를 출력하기</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_1 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
linkedlist_1<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    linkedlist_1<span style=color:#f92672>.</span>add(data)
    
linkedlist_1<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><h2 id=32-특정-데이터를-가진-노드-검색하기>3.2. 특정 데이터를 가진 노드 검색하기<a hidden class=anchor aria-hidden=true href=#32-특정-데이터를-가진-노드-검색하기>#</a></h2><ul><li><code>search_node()</code> 메서드</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
        
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
        

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 &#39;순차적으로&#39; 추가함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>


    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 순회하며 출력함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                
                
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_node</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 검색하기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data: <span style=color:#75715e># 노드의 데이터가 찾고자 하는 데이터가 맞다면 그대로 리턴</span>
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next <span style=color:#75715e># 다음 노드로 순회</span>
</code></pre></div><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_2 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    linkedlist_2<span style=color:#f92672>.</span>add(data)
linkedlist_1<span style=color:#f92672>.</span>print_all()    
    
linkedlist_2<span style=color:#f92672>.</span>search_node(<span style=color:#ae81ff>4</span>)<span style=color:#f92672>.</span>data <span style=color:#75715e># 데이터가 4인 노드의 데이터 출력</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><pre><code class=language-pure_text data-lang=pure_text>    4
</code></pre><p>&nbsp</p><h2 id=33-특정-인덱스의-노드-검색하기>3.3. 특정 인덱스의 노드 검색하기<a hidden class=anchor aria-hidden=true href=#33-특정-인덱스의-노드-검색하기>#</a></h2><ul><li><code>get_node</code> 메서드</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
        
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
        

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 &#39;순차적으로&#39; 추가함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>


    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 순회하며 출력함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next

    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_node</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 검색하기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_node</span>(self, position):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        지정한 인덱스의 노드 가져오기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> position <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> position <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>nodeCount:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Error: Position not in range of length of the linked list.&#34;</span>)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> idx <span style=color:#f92672>&lt;</span> position:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                idx <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
            <span style=color:#66d9ef>return</span> node                    
</code></pre></div><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_3 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    linkedlist_3<span style=color:#f92672>.</span>add(data)

linkedlist_1<span style=color:#f92672>.</span>print_all()  <span style=color:#75715e># 전체 노드 데이터 출력</span>
linkedlist_3<span style=color:#f92672>.</span>get_node(<span style=color:#ae81ff>3</span>)<span style=color:#f92672>.</span>data   <span style=color:#75715e># 3번째 노드의 데이터 출력 </span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><pre><code class=language-pure_text data-lang=pure_text>    3
</code></pre><p>&nbsp</p><h2 id=32-특정-노드-삭제하기>3.2. 특정 노드 삭제하기<a hidden class=anchor aria-hidden=true href=#32-특정-노드-삭제하기>#</a></h2><ul><li><code>delete</code> ㅁㅔ서드</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next

        
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
        

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 &#39;순차적으로&#39; 추가함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>


    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 순회하며 출력함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next

    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_node</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 검색하기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_node</span>(self, position):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        지정한 인덱스의 노드 가져오기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> position <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> position <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>nodeCount:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Error: Position not in range of length of the linked list.&#34;</span>)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> idx <span style=color:#f92672>&lt;</span> position:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                idx <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
            <span style=color:#66d9ef>return</span> node                    
            
            
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>delete</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 삭제
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;No node avaible&#34;</span>)
            <span style=color:#66d9ef>return</span>
        
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:  <span style=color:#75715e># 삭제하고자 하는 데이터가 가장 첫 번째 노드일 때</span>
            temp <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head 
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>next
            <span style=color:#66d9ef>del</span> temp
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:  <span style=color:#75715e># 삭제하고자 하는 데이터가 다음 노드에 있을 때</span>
                    temp <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                    node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next <span style=color:#75715e># 다음 노드를 건너 뛰고, 다음다음 노드를 바로 연결</span>
                    <span style=color:#66d9ef>del</span> temp
                    <span style=color:#66d9ef>pass</span>
                <span style=color:#66d9ef>else</span>:
                    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
</code></pre></div><p><strong>노드를 한개(헤드) 만들어서 <code>delete</code> 메서드 실험하기</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_4 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
linkedlist_4<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_4<span style=color:#f92672>.</span>head  <span style=color:#75715e># 헤드가 존재함</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    &lt;__main__.Node at 0x107e94d10&gt;
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_4<span style=color:#f92672>.</span>delete(<span style=color:#ae81ff>0</span>) <span style=color:#75715e># 헤드를 삭제</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_4<span style=color:#f92672>.</span>head <span style=color:#75715e># 헤드 삭제 후에는 헤드가 출력되지 않음</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_4<span style=color:#f92672>.</span>print_all() <span style=color:#75715e># 링크드 리스트에 노드가 존재하지 않음</span>
</code></pre></div><p>&nbsp</p><p><strong>여러 노드를 추가해서 <code>delete</code> 메서드 실험하기</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_5 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)

<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    linkedlist_5<span style=color:#f92672>.</span>add(data)
    
linkedlist_5<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_5<span style=color:#f92672>.</span>delete(<span style=color:#ae81ff>6</span>)  <span style=color:#75715e># 노드 한개를 삭제함</span>
linkedlist_5<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_5<span style=color:#f92672>.</span>delete(<span style=color:#ae81ff>3</span>)
linkedlist_5<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    4
    5
    7
    8
    9
</code></pre><p>&nbsp</p><h2 id=33-새-노드-중간에-삽입하기>3.3. 새 노드 중간에 삽입하기<a hidden class=anchor aria-hidden=true href=#33-새-노드-중간에-삽입하기>#</a></h2><ul><li><code>insert</code> 메서드</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next

        
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
        

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 &#39;순차적으로&#39; 추가함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>


    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        노드를 순회하며 출력함.
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next

    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_node</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 검색하기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_node</span>(self, position):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        지정한 인덱스의 노드 가져오기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> position <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> position <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>nodeCount:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Error: Position not in range of length of the linked list.&#34;</span>)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> idx <span style=color:#f92672>&lt;</span> position:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                idx <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
            <span style=color:#66d9ef>return</span> node                    
            
            
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>delete</span>(self, data):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        특정 데이터를 가진 노드 삭제
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;No node avaible&#34;</span>)
            <span style=color:#66d9ef>return</span>
        
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:  <span style=color:#75715e># 삭제하고자 하는 데이터가 가장 첫 번째 노드일 때</span>
            temp <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head 
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>next
            <span style=color:#66d9ef>del</span> temp
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:  <span style=color:#75715e># 삭제하고자 하는 데이터가 다음 노드에 있을 때</span>
                    temp <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                    node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next<span style=color:#f92672>.</span>next <span style=color:#75715e># 다음 노드를 건너 뛰고, 다음다음 노드를 바로 연결</span>
                    <span style=color:#66d9ef>del</span> temp
                    <span style=color:#66d9ef>pass</span>
                <span style=color:#66d9ef>else</span>:
                    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next

                    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert</span>(self, data, position_index):
        <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>        지정한 위치에 데이터 노드 삽입하기
</span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
        <span style=color:#66d9ef>if</span> position_index <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e># head 위치에 삽입하기</span>
            temp <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> temp
            self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
        <span style=color:#66d9ef>elif</span> position_index <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>:
            <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Error: Insert index exceeds the length of linked list&#34;</span>)
            <span style=color:#66d9ef>return</span>
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            search_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
            search_status <span style=color:#f92672>=</span> True
            <span style=color:#66d9ef>while</span> search_status:
                search_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
                <span style=color:#66d9ef>if</span> search_index <span style=color:#f92672>==</span> position_index:
                    search_status <span style=color:#f92672>=</span> False
                    insert_node <span style=color:#f92672>=</span> Node(data)

                    node_next <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                    node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> insert_node
                    insert_node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node_next
                    self<span style=color:#f92672>.</span>nodeCount <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
                <span style=color:#66d9ef>else</span>:
                    node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_6 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    linkedlist_6<span style=color:#f92672>.</span>add(data)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_6<span style=color:#f92672>.</span>print_all() <span style=color:#75715e># 노드 순회하며 데이터 출력하기</span>
linkedlist_6<span style=color:#f92672>.</span>nodeCount <span style=color:#75715e># 노드 개수 출력하기</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><pre><code class=language-pure_text data-lang=pure_text>    10
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>linkedlist_6<span style=color:#f92672>.</span>insert(<span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>7</span>)  <span style=color:#75715e># 17이라는 데이터를 7번째 인덱스에 넣기</span>
linkedlist_6<span style=color:#f92672>.</span>print_all()
linkedlist_6<span style=color:#f92672>.</span>nodeCount <span style=color:#75715e># 노드 삽입 후 노드 개수 출력</span>
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    17
    7
    8
    9
</code></pre><pre><code class=language-pure_text data-lang=pure_text>    11
</code></pre><p>&nbsp</p><h1 id=4-링크드-리스트의-개선된-타입>4. 링크드 리스트의 개선된 타입<a hidden class=anchor aria-hidden=true href=#4-링크드-리스트의-개선된-타입>#</a></h1><h2 id=41-더블-링크드-리스트--doubly-linked-list>4.1. 더블 링크드 리스트 : Doubly-Linked List<a hidden class=anchor aria-hidden=true href=#41-더블-링크드-리스트--doubly-linked-list>#</a></h2><ul><li>링크드 리스트의 단점을 보완하기 위해 등장함.</li></ul><p><img src=https://static.packt-cdn.com/products/9781788623872/graphics/799b2df2-64a7-4120-8540-f30ce8720e04.png#center alt title="Source: https://subscription.packtpub.com/book/web_development/9781788623872/6/ch06lvl1sec40/doubly-linked-lists"></p><h3 id=411-기본-구조>4.1.1. 기본 구조<a hidden class=anchor aria-hidden=true href=#411-기본-구조>#</a></h3><ul><li>양방향으로 연결되어 있어, 노드 탐색이 양쪽으로 모두 가능한 구조</li><li>즉, 다음 노드를 가리키는 포인터(next) 뿐만 아니라, 이전 노드를 가리키는 포인터(prev)도 존재함.</li></ul><p>&nbsp</p><h3 id=412-더블-링크드-리스트의-장단점>4.1.2. 더블 링크드 리스트의 장단점<a hidden class=anchor aria-hidden=true href=#412-더블-링크드-리스트의-장단점>#</a></h3><p>장점:</p><ul><li>양방향으로 탐색이 가능함.</li></ul><p>단점:</p><ul><li>이전 노드를 가리키는 포인터가 추가되기 때문에 메모리 사용량이 늘어남.</li><li>삽입/삭제 연산에 있어, 앞/뒤 연결링크를 조정해줘야 하기 때문에 구조가 복잡해짐.</li></ul><p>&nbsp</p><h3 id=412-파이썬으로-구현한-더블-링크드-리스트>4.1.2. 파이썬으로 구현한 더블 링크드 리스트<a hidden class=anchor aria-hidden=true href=#412-파이썬으로-구현한-더블-링크드-리스트>#</a></h3><ul><li>더블 링크드 리스트의 노드는 이전 노드와 다음 노드를 가리키는 포인터를 포함하는 것이 핵심.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, prev<span style=color:#f92672>=</span>None, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            new <span style=color:#f92672>=</span> Node(data)
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new
            new<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> new
            
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
</code></pre></div><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    double_linked_list<span style=color:#f92672>.</span>add(data)
double_linked_list<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><h2 id=42-더블-링크드-리스트의-검색과-삽입>4.2. 더블 링크드 리스트의 검색과 삽입<a hidden class=anchor aria-hidden=true href=#42-더블-링크드-리스트의-검색과-삽입>#</a></h2><h3 id=421-특정-노드-이전에-새로운-노드-삽입하기>4.2.1. 특정 노드 이전에 새로운 노드 삽입하기<a hidden class=anchor aria-hidden=true href=#421-특정-노드-이전에-새로운-노드-삽입하기>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, prev<span style=color:#f92672>=</span>None, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            new <span style=color:#f92672>=</span> Node(data)
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new
            new<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> new
                
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
        
        
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_from_head</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            <span style=color:#66d9ef>return</span> None
        
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
        <span style=color:#66d9ef>return</span> None
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_from_tail</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            <span style=color:#66d9ef>return</span> None
        
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
        <span style=color:#66d9ef>return</span> None
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert_before</span>(self, data, prev_data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>!=</span> prev_data:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
                <span style=color:#66d9ef>if</span> node <span style=color:#f92672>==</span> None:
                    <span style=color:#66d9ef>return</span> None
                
            new_node <span style=color:#f92672>=</span> Node(data)
            prev_new <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
            prev_new<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new_node
            new_node<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev_new
            new_node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node
            node<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> new_node
            <span style=color:#66d9ef>return</span> None
</code></pre></div><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    double_linked_list<span style=color:#f92672>.</span>add(data)
double_linked_list<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 뒤에서부터 찾기</span>
node_3 <span style=color:#f92672>=</span> double_linked_list<span style=color:#f92672>.</span>search_from_tail(<span style=color:#ae81ff>3</span>)
node_3<span style=color:#f92672>.</span>data
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    3
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 앞에서부터 찾기</span>
node_8 <span style=color:#f92672>=</span> double_linked_list<span style=color:#f92672>.</span>search_from_head(<span style=color:#ae81ff>8</span>)
node_8<span style=color:#f92672>.</span>data
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    8
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list<span style=color:#f92672>.</span>insert_before(<span style=color:#ae81ff>4.5</span>, <span style=color:#ae81ff>5</span>)
double_linked_list<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    4.5
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>node_4_5 <span style=color:#f92672>=</span> double_linked_list<span style=color:#f92672>.</span>search_from_tail(<span style=color:#ae81ff>4.5</span>)
node_4_5<span style=color:#f92672>.</span>data
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    4.5
</code></pre><p>&nbsp</p><h3 id=422-특정-노드-이후에-새로운-노드-삽입하기>4.2.2. 특정 노드 이후에 새로운 노드 삽입하기<a hidden class=anchor aria-hidden=true href=#422-특정-노드-이후에-새로운-노드-삽입하기>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data, prev<span style=color:#f92672>=</span>None, next<span style=color:#f92672>=</span>None):
        self<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> prev
        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
        self<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next
        
        
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NodeManagement</span>:
    <span style=color:#66d9ef>def</span> __init__(self, data):
        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
        self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>next:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            new <span style=color:#f92672>=</span> Node(data)
            node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new
            new<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node
            self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> new
                
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_all</span>(self):
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>print</span>(node<span style=color:#f92672>.</span>data)
            node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
        
        
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_from_head</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            <span style=color:#66d9ef>return</span> None
        
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
        <span style=color:#66d9ef>return</span> None
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_from_tail</span>(self, data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            <span style=color:#66d9ef>return</span> None
        
        node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail
        <span style=color:#66d9ef>while</span> node:
            <span style=color:#66d9ef>if</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>==</span> data:
                <span style=color:#66d9ef>return</span> node
            <span style=color:#66d9ef>else</span>:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
        <span style=color:#66d9ef>return</span> None
    
    
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert_before</span>(self, data, prev_data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>tail
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>!=</span> prev_data:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
                <span style=color:#66d9ef>if</span> node <span style=color:#f92672>==</span> None:
                    <span style=color:#66d9ef>return</span> None
                
            new_node <span style=color:#f92672>=</span> Node(data)
            
            prev_new <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>prev
            prev_new<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new_node
            
            new_node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> node
            <span style=color:#66d9ef>return</span> None
        
        
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>insert_after</span>(self, data, next_data):
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> None:
            self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Node(data)
            <span style=color:#66d9ef>return</span> None
        
        <span style=color:#66d9ef>else</span>:
            node <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
            <span style=color:#66d9ef>while</span> node<span style=color:#f92672>.</span>data <span style=color:#f92672>!=</span> next_data:
                node <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
                <span style=color:#66d9ef>if</span> node <span style=color:#f92672>==</span> None:
                    <span style=color:#66d9ef>return</span> None
                
            new_node <span style=color:#f92672>=</span> Node(data)
            
            next_new <span style=color:#f92672>=</span> node<span style=color:#f92672>.</span>next
            new_node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> next_new
            
            new_node<span style=color:#f92672>.</span>prev <span style=color:#f92672>=</span> node
            <span style=color:#66d9ef>if</span> new_node<span style=color:#f92672>.</span>next <span style=color:#f92672>==</span> None:
                self<span style=color:#f92672>.</span>tail <span style=color:#f92672>=</span> new_node
            <span style=color:#66d9ef>else</span>:
                node<span style=color:#f92672>.</span>next <span style=color:#f92672>=</span> new_node
            <span style=color:#66d9ef>return</span> True
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list_2 <span style=color:#f92672>=</span> NodeManagement(<span style=color:#ae81ff>0</span>)
<span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>):
    double_linked_list_2<span style=color:#f92672>.</span>add(data)
    
double_linked_list_2<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list_2<span style=color:#f92672>.</span>insert_after(<span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2</span>)
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    True
</code></pre><p>&nbsp</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>double_linked_list_2<span style=color:#f92672>.</span>print_all()
</code></pre></div><pre><code class=language-pure_text data-lang=pure_text>    0
    1
    2
    2.5
    3
    4
    5
    6
    7
    8
    9
</code></pre><h1 id=5-정리해보기>5. 정리해보기<a hidden class=anchor aria-hidden=true href=#5-정리해보기>#</a></h1><ul><li>배열 리스트는 일정한 공간을 할당 후, 그 공간 안에서 물리적인 순서를 가지는 자료구조이다.</li><li>반대로 링크드 리스트(연결리스트)는 데이터를 담고 있는 노드들의 논리적인 순서를 위한 자료구조이다.</li><li>논리적인 구조는 이전/다음 노드를 가리키는 포인터를 통해 정의한다.</li><li>링크드 리스트는 처음부터 특정 공간을 할당하지 않아 메모리 활용도가 유연하고, 메모리 낭비를 막을 수 있다.</li><li>삽입과 삭제가 빠르다. 구현 작업은 다소 복잡할 지 모르나, 구현 후 실행은 간단하다.</li><li>하지만 포인터라는 요소까지 포함하여야 하기 때문에 비교적 더 큰 공간을 잡아먹는다.</li><li>또한 배열와는 달리, 순차적으로 노드를 훑으며 노드를 찾아가야 하기 때문에 시간이 좀 더 걸린다.</li><li>단순한 링크드 리스트는 한방향으로만 노드를 탐색하기 때문에 비효율적일 수 있다.</li><li>양방향 링크드 리스트는 앞/뒤에서부터 동시에 노드를 탐색하기 때문에 단순 링크드 리스트의 단점을 보완할 수 있다.</li></ul><h1 id=6-reference>6. Reference<a hidden class=anchor aria-hidden=true href=#6-reference>#</a></h1><ul><li>Fastcampus 알고리즘 / 기술면접 강의</li><li><a href=https://programmers.co.kr/learn/courses/57 target=_blank>프로그래머스 프로그램밍 강의 어서와! 자료구조는 처음이지?</a></li><li><a href=https://opentutorials.org/module/1335/8821 target=_blank>생활코딩</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lucaseo.github.io/tags/data-structure/>data structure</a></li><li><a href=https://lucaseo.github.io/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>