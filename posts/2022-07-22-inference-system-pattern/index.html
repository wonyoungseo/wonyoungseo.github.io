<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[KR] 머신러닝 추론 시스템 패턴 | Wonyoung's Tech Blog</title><meta name=keywords content="mlops,ml,inference system"><meta name=description content="0. 머신러닝 추론 시스템이란 최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, 이번 글에서는 머신러닝 파이프라인의 한 부분을 담당하는 추론 시스템(ML inference system)에 대해 간단히 정리해보았다.
머신러닝 추론 시스템은 학습된 머신러닝 모델을 불러와 실제 데이터에 대한 추론 결과를 사용자에게 제공하는 기능을 한다. 추론시스템은 누군가가 실제로 머신러닝 모델 프로덕트를 사용한다. 따라서, 머신러닝에서 우리가 익숙한 [데이터수집 -> 데이터정제 -> 모델링 -> 학습 -> 성능평가 -> 실험반복]의 패턴과는 확연히 다르며, 다양한 관점에서 고려해야할 부분들이 생긴다."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://wonyoungseo.github.io/posts/2022-07-22-inference-system-pattern/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="[KR] 머신러닝 추론 시스템 패턴"><meta property="og:description" content="0. 머신러닝 추론 시스템이란 최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, 이번 글에서는 머신러닝 파이프라인의 한 부분을 담당하는 추론 시스템(ML inference system)에 대해 간단히 정리해보았다.
머신러닝 추론 시스템은 학습된 머신러닝 모델을 불러와 실제 데이터에 대한 추론 결과를 사용자에게 제공하는 기능을 한다. 추론시스템은 누군가가 실제로 머신러닝 모델 프로덕트를 사용한다. 따라서, 머신러닝에서 우리가 익숙한 [데이터수집 -> 데이터정제 -> 모델링 -> 학습 -> 성능평가 -> 실험반복]의 패턴과는 확연히 다르며, 다양한 관점에서 고려해야할 부분들이 생긴다."><meta property="og:type" content="article"><meta property="og:url" content="https://wonyoungseo.github.io/posts/2022-07-22-inference-system-pattern/"><meta property="og:image" content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2022-07-22T21:10:24+09:00"><meta property="article:modified_time" content="2022-07-22T21:10:24+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[KR] 머신러닝 추론 시스템 패턴"><meta name=twitter:description content="0. 머신러닝 추론 시스템이란 최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, 이번 글에서는 머신러닝 파이프라인의 한 부분을 담당하는 추론 시스템(ML inference system)에 대해 간단히 정리해보았다.
머신러닝 추론 시스템은 학습된 머신러닝 모델을 불러와 실제 데이터에 대한 추론 결과를 사용자에게 제공하는 기능을 한다. 추론시스템은 누군가가 실제로 머신러닝 모델 프로덕트를 사용한다. 따라서, 머신러닝에서 우리가 익숙한 [데이터수집 -> 데이터정제 -> 모델링 -> 학습 -> 성능평가 -> 실험반복]의 패턴과는 확연히 다르며, 다양한 관점에서 고려해야할 부분들이 생긴다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[KR] 머신러닝 추론 시스템 패턴","name":"[KR] 머신러닝 추론 시스템 패턴","description":"0. 머신러닝 추론 시스템이란 최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, …","keywords":["mlops","ml","inference system"],"articleBody":"0. 머신러닝 추론 시스템이란 최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, 이번 글에서는 머신러닝 파이프라인의 한 부분을 담당하는 추론 시스템(ML inference system)에 대해 간단히 정리해보았다.\n머신러닝 추론 시스템은 학습된 머신러닝 모델을 불러와 실제 데이터에 대한 추론 결과를 사용자에게 제공하는 기능을 한다. 추론시스템은 누군가가 실제로 머신러닝 모델 프로덕트를 사용한다. 따라서, 머신러닝에서 우리가 익숙한 [데이터수집 - 데이터정제 - 모델링 - 학습 - 성능평가 - 실험반복]의 패턴과는 확연히 다르며, 다양한 관점에서 고려해야할 부분들이 생긴다.\n추론시스템은 목적과 자원에 따라 여러가지가 있어, 각 케이스와 구현 방식에 따라 정보가 매우 파편적이었지만, 머신러닝 시스템 디자인 패턴(저자: 시부이 유우스케) 에서 포괄적으로 여러가지 케이스에 대해 다루고 있어 아주 좋은 자료가 되었다. 패턴에 대한 네이밍은 다양하게 있을 수 있으나, 해당 포스트에서는 책의 네이밍과 내용을 참고하여 정리했다.\n\u0026nbsp\n 1. 추론 시스템의 베이스 패턴 1.1. 웹 싱글 패턴 개념과 구조:\n 하나의 API 서버에 하나의 추론 모델이 동작함. 사용자는 API에 데이터를 전송하여, 그에 따른 모델 추론 결과를 받음.  목적 또는 사용 예시:\n 모델 구현 등 간단한 프로젝트의 시연 결과물 실제 데이터를 대상으로 모델의 성능을 검증하는 단계에 적합  장점:\n 간단하게 구현 가능.  주의점:\n 2개 이상의 모델이 추가되어야 하거나, 전처리 등의 추가 단계를 거쳐야 한다면 적합한 패턴이 될 수 없음.  \u0026nbsp\n1.2. 전처리 추론 패턴 개념과 구조:\n 대부분의 경우 실제 데이터에 대하여 전처리 이후 추론하는 경우가 많음. 전처리와 추론을 분리하여 코드 관리와 유지보수를 용이하게 함. 전처리와 추론 시스템을 개별 API 서버로 구분하여 개발함.  목적 또는 적용 예시:\n 전처리와 추론에서 필요로 하는 라이브러리, 코드 베이스, 리소스 등이 크게 다를 경우 전처리와 추론 시스템의 개발의 구분해야 하는 경우  장점:\n 전처리와 추론 과정 간 장애의 격리하고, 각 과정의 개발을 구분함. 사용되는 리소스를 효율적으로 관리할 수 있음. 사용할 수 있는 라이브러리와 버전 등을 유연하게 선택할 수 있음.  주의점:\n 추론시스템은 학습된 시점에 사용된 전처리 방식과 모델을 사용해야 하므로, 전처리 시스템과 추론 시스템은 늘 동일한 버전을 유지해야 함.  \u0026nbsp\n1.3. 배치 추론 패턴 개념과 구조:\n 배치 추론 패턴은 일정한 주기마다 다량의 데이터에 대하여 추론을 실시함. 학습된 모델이 API 서버가 아닌, 스케쥴러에 의해 동작함.  목적 또는 적용 예시:\n 모델이 동작하는 방식이 굳이 실시간(real-time) 또는 실시간에 준하는(near-real-time) 추론이 요구되지 않는 경우 일정한 시간동안 데이터를 적재한 뒤 주기적으로 주기적으로 추론하는 경우 과거의 데이터에 대하여 추론하고 싶은 경우 (historical data)  장점:\n 배치 추론이 실행될 때만 자원을 사용하면 되기에, 비용 절감 가능 장애 대응 등 시간적 여유를 가지고 추론이 가능함 (단, 비즈니스가 이러한 여유를 허용할 경우)  주의점:\n 시간의 지남에 따라 데이터의 특성이 변화하는 상황이 발생한 경우 적기에 대응이 쉽지 않으므로, 모니터링 기준이 필요함. 소량의 데이터라도 짧은 주기에 한번씩 추론을 실행하여 결과를 확인하는 과정이 필요할 수 있음.  \u0026nbsp\n 2. 순서에 대한 패턴 2.1. 동기 추론 패턴 개념과 구조:\n 모델이 동작하는 서버에 요청을 하여 추론 결과가 나올 때까지 기다리는 구조를 동기추론 패턴이라 함.  목적 또는 적용 예시:\n 추론 이후의 단계가 추론 결과에 의존 하는 경우. 예시) 불량품 검출 모델 결과를 반환받아, 불량품을 정상 제품으로부터 분리 함.  장점:\n 각 작업이 순차적이고 직관적임. 개발이 다소 간단함.  주의점:\n 프로세스에 병목현상을 야기하는 작업단계가 있을 경우, 사용자는 추론 결과를 받기까지 기다려야 하는 시간이 길어짐. 따라서 작업의 속도를 개선하거나, 모델의 경량화 또는 비동기 추론 패턴을 적용한 프로세스를 고려하는 것이 적합함.  \u0026nbsp\n2.2. 비동기 추론 패턴 개념과 구조:\n 사용자는 추론 요청을 하고 결과가 반환 때까지 기다리지 않고 다른 작업을 수행할 수 있으며, 추론이 완료되었을 때 개별적으로 결과를 확인할 수 있음. (비동기적인 처리) 사용자의 요청을 큐 또는 캐시로 저장하여 순차적으로 추론한 뒤, 추론이 완료되었을 결과를 DB에 저장하고 사용자에게 추론 결과가 반환되었으며 확인이 가능함을 알림.  목적 또는 적용 예시:\n 비즈니스 로직에 따라, 모델의 결과를 즉시 반환하지 않아도 되는 경우. 모델의 추론 시간이 오래 걸리는 경우.  장점:\n 추론 과정에서 발생할 수 있는 병목현상을 해결할 수 있음. 어떻게 설계했는지에 따라 사용자 경험을 개선할 수 있음.  주의점:\n 사용자의 요청을 저장하고 추론하는 순서를 경우에 따라 선택해야하며, 시스템 장애가 발생하는 경우 대응 방법을 고려해야 함.  \u0026nbsp\n 3. 2개 이상의 모델에 대한 추론 패턴 3.1. 직렬 마이크로서비스 패턴 개념과 구조:\n 2개 이상의 모델 추론이 필요한 어플리케이션에서, 모델 간의 순서의 의존성이 존재하는 경우. 단, 여러 개의 추론 시스템을 마이크로서비스로 구현하여, 각 모델 간의 결합도를 낮춤. 모델이 구동되는 여러 개의 추론 마이크로서비스를 워크플로우 파이프라인을 통해 DAG(directed acyclic graph)의 형태로 연결하여 구현할 수 있음.  목적 또는 적용 예시:\n 여러 개의 모델이 순차적으로 실행되어 최종적으로 하나의 결과를 반환하는 유형에 적합.  장점:\n 모델과 추론 시스템의 사이즈가 커질 수록, 마이크로서비스 패턴은 리소스 비용을 효율적으로 관리할 수 있음. 독립적으로 구성되어 있기 때문에 직전 추론 결과에 따라 분기처리 또한 가능.  주의점:\n 동기 추론 패턴과 마찬가지로 추론에 걸리는 시간에 따라 병목현상이 발생할 수 있음. 마이크로서비스 패턴은 서버간 통신으로 인한 지연도 발생할 수 있음.  \u0026nbsp\n3.2. 병렬 마이크로서비스 패턴 개념과 구조:\n 여러 개의 추론 마이크로서비스가 의존관계 없이 병렬로 실행되어 결과가 저장됨. 필요에 따라서는 각 추론 결과를 마지막에 집계하는 구조도 가능함.  목적 또는 적용 예시:\n 하나의 데이터에 대해 여러가지의 모델이 추론을 해야하는 상황에 적합함.  장점:\n 의존 관계가 없어 유연하게 설계가 가능함. 각 모델의 추론 서버가 구별되어, 리소스 관리나 장애 대응이 용이해짐.  주의점:\n 각 추론 서버들의 결과 반환 속도가 다르므로, 결과를 집계하는 방식에 대한 고려가 필요함.  \u0026nbsp\n 4. 캐싱 패턴 4.1. 추론 캐시 패턴 개념과 구조:\n 추론 결과를 캐시로 저장하고, 추후 동일한 데이터에 대해 추론 요청이 있을 때는 추론할 필요 없이 캐시된 결과를 반환하는 개념. 입력된 데이터가 저장되고 식별 및 검색이 가능해야 함. 데이터에 매핑되어 저장된 추론 결과를 반환해야 하기 때문.  목적 또는 적용 예시:\n 동일한 데이터가 추후에도 입력될 수 있고, 추론 시간을 단축해야 하는 경우.  장점:\n 추론 속도를 단축할 수 있으며, 추론 시스템이 구동되는 리소스의 비용을 줄일 수 있음.  주의점:\n 입력 데이터가 적재되는 저장공간과 추론 결과가 저장되는 캐시로 인한 비용이 발생할 수 있음. 동일한 데이터가 발생되는 유형의 목적에 유효한 패턴이며, 그 외 “유사한 데이터” 수준인 경우에는 적용되지 않음.  \u0026nbsp\n4.2. 데이터 캐시 패턴 개념과 구조:\n 동일한 데이터에 대해 추론 요청이 있을 경우, 데이터 전처리 결과를 캐시하여 추론하는 경우. 추론 캐시 패턴과 유사하며 함께 사용될 수 있음. 추론 캐싱 패턴과 마찬가지로 입력 데이터가 식별이 가능해야 함.  목적 또는 적용 예시:\n 데이터 전처리, 피쳐 추출 등 데이터 처리와 관련된 시간이나 비용이 클 경우 적용할 수 있음.  장점:\n 빈번하게 발생하는 동일한 데이터 전처리와 피쳐 추출로 인해 발생하는 비용을 줄일 수 있음.  주의점:\n 추론 캐싱 패턴과 마찬가지로, 캐시가 적재되는 용량과 그에 따른 비용이 커질 수 있음.  \u0026nbsp\n 5. 추론 시스템의 안티 패턴 추론 시스템을 구축할 때는 지양해야 하지만 간과하기 쉬운 안티 패턴이 몇 가지 있다.\n5.1. 온라인 빅사이즈 패턴 개념:\n 실시간 처리, 스트리밍 데이터에 대한 추론에 큰 규모의 모델을 적용, 이에 따라 서비스 지연이 발생하는 경우 배치 추론의 구조를 가지고 있지만, 1회 배치 추론의 시간이 배치 추론 주기를 초과하는 경우  접근 방법:\n 리소스 규모를 확대하여 처리 속도를 개선함. 2개 이상의 모델일 경우 가벼운 모델과 무거운 모델의 서비스를 분리함. 캐싱 패턴을 통해 속도를 개선함. 완벽하고 거대한 모델이 아닌 비즈니스 요구에 충족하는 수준의 모델을 개발함.  5.2. 올인원 패턴 개념:\n 하나의 서버에서 전처리, 2개 이상의 모델 등 모든 것을 가동하는 경우 활용하는 리소스의 비용은 절약할 수 있으나, 다음과 같은 측면에서 운영이 용이하지 않음.  장애 대응 시스템 갱신 모델 갱신 및 관리 라이브러리 갱신    접근 방법:\n 전처리, 추론 모델 서버 등을 마이크로서비스로 구현함.  \u0026nbsp\n 7. 마무리하며 추론 시스템을 개발하기 위한 다양한 패턴과 고려해야할 점들을 훑어보았다. 기존의 데이터사이언티스트 관점에서 막막한 영역이었으나, 개념이 정리되어 앞으로의 업무에 도움이 많이 되었다. 현업에서는 훨씬 복잡한 서비스를 위해 위에서 정리한 패턴에 그치지 않고 이를 조합하거나 새로운 패턴을 고안할 것으로 생각된다. 정리한 내용을 토대로 앞으로는 다른 기업의 케이스 등을 분석해보고 업무에 참고할 수 있을 것 같다.\n","wordCount":"1179","inLanguage":"en","datePublished":"2022-07-22T21:10:24+09:00","dateModified":"2022-07-22T21:10:24+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wonyoungseo.github.io/posts/2022-07-22-inference-system-pattern/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wonyoungseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wonyoungseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://wonyoungseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wonyoungseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wonyoungseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://wonyoungseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[KR] 머신러닝 추론 시스템 패턴</h1><div class=post-meta>July 22, 2022&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#0-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%ec%b6%94%eb%a1%a0-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%b4%eb%9e%80 aria-label="0. 머신러닝 추론 시스템이란">0. 머신러닝 추론 시스템이란</a></li><li><a href=#1-%ec%b6%94%eb%a1%a0-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ed%8c%a8%ed%84%b4 aria-label="1. 추론 시스템의 베이스 패턴">1. 추론 시스템의 베이스 패턴</a><ul><li><a href=#11--%ec%9b%b9-%ec%8b%b1%ea%b8%80-%ed%8c%a8%ed%84%b4 aria-label="1.1.  웹 싱글 패턴">1.1. 웹 싱글 패턴</a></li><li><a href=#12-%ec%a0%84%ec%b2%98%eb%a6%ac-%ec%b6%94%eb%a1%a0-%ed%8c%a8%ed%84%b4 aria-label="1.2. 전처리 추론 패턴">1.2. 전처리 추론 패턴</a></li><li><a href=#13-%eb%b0%b0%ec%b9%98-%ec%b6%94%eb%a1%a0-%ed%8c%a8%ed%84%b4 aria-label="1.3. 배치 추론 패턴">1.3. 배치 추론 패턴</a></li></ul></li><li><a href=#2-%ec%88%9c%ec%84%9c%ec%97%90-%eb%8c%80%ed%95%9c-%ed%8c%a8%ed%84%b4 aria-label="2. 순서에 대한 패턴">2. 순서에 대한 패턴</a><ul><li><a href=#21-%eb%8f%99%ea%b8%b0-%ec%b6%94%eb%a1%a0-%ed%8c%a8%ed%84%b4 aria-label="2.1. 동기 추론 패턴">2.1. 동기 추론 패턴</a></li><li><a href=#22-%eb%b9%84%eb%8f%99%ea%b8%b0-%ec%b6%94%eb%a1%a0-%ed%8c%a8%ed%84%b4 aria-label="2.2. 비동기 추론 패턴">2.2. 비동기 추론 패턴</a></li></ul></li><li><a href=#3-2%ea%b0%9c-%ec%9d%b4%ec%83%81%ec%9d%98-%eb%aa%a8%eb%8d%b8%ec%97%90-%eb%8c%80%ed%95%9c-%ec%b6%94%eb%a1%a0-%ed%8c%a8%ed%84%b4 aria-label="3. 2개 이상의 모델에 대한 추론 패턴">3. 2개 이상의 모델에 대한 추론 패턴</a><ul><li><a href=#31-%ec%a7%81%eb%a0%ac-%eb%a7%88%ec%9d%b4%ed%81%ac%eb%a1%9c%ec%84%9c%eb%b9%84%ec%8a%a4-%ed%8c%a8%ed%84%b4 aria-label="3.1. 직렬 마이크로서비스 패턴">3.1. 직렬 마이크로서비스 패턴</a></li><li><a href=#32-%eb%b3%91%eb%a0%ac-%eb%a7%88%ec%9d%b4%ed%81%ac%eb%a1%9c%ec%84%9c%eb%b9%84%ec%8a%a4-%ed%8c%a8%ed%84%b4 aria-label="3.2. 병렬 마이크로서비스 패턴">3.2. 병렬 마이크로서비스 패턴</a></li></ul></li><li><a href=#4-%ec%ba%90%ec%8b%b1-%ed%8c%a8%ed%84%b4 aria-label="4. 캐싱 패턴">4. 캐싱 패턴</a><ul><li><a href=#41-%ec%b6%94%eb%a1%a0-%ec%ba%90%ec%8b%9c-%ed%8c%a8%ed%84%b4 aria-label="4.1. 추론 캐시 패턴">4.1. 추론 캐시 패턴</a></li><li><a href=#42-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%ba%90%ec%8b%9c-%ed%8c%a8%ed%84%b4 aria-label="4.2. 데이터 캐시 패턴">4.2. 데이터 캐시 패턴</a></li></ul></li><li><a href=#5-%ec%b6%94%eb%a1%a0-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ec%95%88%ed%8b%b0-%ed%8c%a8%ed%84%b4 aria-label="5. 추론 시스템의 안티 패턴">5. 추론 시스템의 안티 패턴</a><ul><li><a href=#51-%ec%98%a8%eb%9d%bc%ec%9d%b8-%eb%b9%85%ec%82%ac%ec%9d%b4%ec%a6%88-%ed%8c%a8%ed%84%b4 aria-label="5.1. 온라인 빅사이즈 패턴">5.1. 온라인 빅사이즈 패턴</a></li><li><a href=#52-%ec%98%ac%ec%9d%b8%ec%9b%90-%ed%8c%a8%ed%84%b4 aria-label="5.2. 올인원 패턴">5.2. 올인원 패턴</a></li></ul></li><li><a href=#7-%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label="7. 마무리하며">7. 마무리하며</a></li></ul></div></details></div><div class=post-content><h2 id=0-머신러닝-추론-시스템이란>0. 머신러닝 추론 시스템이란<a hidden class=anchor aria-hidden=true href=#0-머신러닝-추론-시스템이란>#</a></h2><p>최근 머신러닝 모델을 서비스하기 위한 파이프라인을 구축하는 프로젝트를 진행하게 되었다. 경험 없이 밑바닥에서부터 시작하는 입장이었기 때문에 프로젝트를 본격적으로 진행하기에 앞서 여러가지 케이스를 분석하고 참고하는 시간을 가져보았다. 그 과정의 일환으로, 이번 글에서는 머신러닝 파이프라인의 한 부분을 담당하는 추론 시스템(ML inference system)에 대해 간단히 정리해보았다.</p><p>머신러닝 추론 시스템은 학습된 머신러닝 모델을 불러와 실제 데이터에 대한 추론 결과를 사용자에게 제공하는 기능을 한다. 추론시스템은 누군가가 실제로 머신러닝 모델 프로덕트를 사용한다. 따라서, 머신러닝에서 우리가 익숙한 [데이터수집 -> 데이터정제 -> 모델링 -> 학습 -> 성능평가 -> 실험반복]의 패턴과는 확연히 다르며, 다양한 관점에서 고려해야할 부분들이 생긴다.</p><p>추론시스템은 목적과 자원에 따라 여러가지가 있어, 각 케이스와 구현 방식에 따라 정보가 매우 파편적이었지만, <strong><em>머신러닝 시스템 디자인 패턴(저자: 시부이 유우스케)</em></strong> 에서 포괄적으로 여러가지 케이스에 대해 다루고 있어 아주 좋은 자료가 되었다. 패턴에 대한 네이밍은 다양하게 있을 수 있으나, 해당 포스트에서는 책의 네이밍과 내용을 참고하여 정리했다.</p><p>&nbsp</p><hr><h2 id=1-추론-시스템의-베이스-패턴>1. 추론 시스템의 베이스 패턴<a hidden class=anchor aria-hidden=true href=#1-추론-시스템의-베이스-패턴>#</a></h2><h3 id=11--웹-싱글-패턴>1.1. 웹 싱글 패턴<a hidden class=anchor aria-hidden=true href=#11--웹-싱글-패턴>#</a></h3><p>개념과 구조:</p><ul><li>하나의 API 서버에 하나의 추론 모델이 동작함.</li><li>사용자는 API에 데이터를 전송하여, 그에 따른 모델 추론 결과를 받음.</li></ul><p>목적 또는 사용 예시:</p><ul><li>모델 구현 등 간단한 프로젝트의 시연 결과물</li><li>실제 데이터를 대상으로 모델의 성능을 검증하는 단계에 적합</li></ul><p>장점:</p><ul><li>간단하게 구현 가능.</li></ul><p>주의점:</p><ul><li>2개 이상의 모델이 추가되어야 하거나, 전처리 등의 추가 단계를 거쳐야 한다면 적합한 패턴이 될 수 없음.</li></ul><p>&nbsp</p><h3 id=12-전처리-추론-패턴>1.2. 전처리 추론 패턴<a hidden class=anchor aria-hidden=true href=#12-전처리-추론-패턴>#</a></h3><p>개념과 구조:</p><ul><li>대부분의 경우 실제 데이터에 대하여 전처리 이후 추론하는 경우가 많음.</li><li>전처리와 추론을 분리하여 코드 관리와 유지보수를 용이하게 함.</li><li>전처리와 추론 시스템을 개별 API 서버로 구분하여 개발함.</li></ul><p>목적 또는 적용 예시:</p><ul><li>전처리와 추론에서 필요로 하는 라이브러리, 코드 베이스, 리소스 등이 크게 다를 경우</li><li>전처리와 추론 시스템의 개발의 구분해야 하는 경우</li></ul><p>장점:</p><ul><li>전처리와 추론 과정 간 장애의 격리하고, 각 과정의 개발을 구분함.</li><li>사용되는 리소스를 효율적으로 관리할 수 있음.</li><li>사용할 수 있는 라이브러리와 버전 등을 유연하게 선택할 수 있음.</li></ul><p>주의점:</p><ul><li>추론시스템은 학습된 시점에 사용된 전처리 방식과 모델을 사용해야 하므로, 전처리 시스템과 추론 시스템은 늘 동일한 버전을 유지해야 함.</li></ul><p>&nbsp</p><h3 id=13-배치-추론-패턴>1.3. 배치 추론 패턴<a hidden class=anchor aria-hidden=true href=#13-배치-추론-패턴>#</a></h3><p>개념과 구조:</p><ul><li>배치 추론 패턴은 일정한 주기마다 다량의 데이터에 대하여 추론을 실시함.</li><li>학습된 모델이 API 서버가 아닌, 스케쥴러에 의해 동작함.</li></ul><p>목적 또는 적용 예시:</p><ul><li>모델이 동작하는 방식이 굳이 실시간(real-time) 또는 실시간에 준하는(near-real-time) 추론이 요구되지 않는 경우</li><li>일정한 시간동안 데이터를 적재한 뒤 주기적으로 주기적으로 추론하는 경우</li><li>과거의 데이터에 대하여 추론하고 싶은 경우 (historical data)</li></ul><p>장점:</p><ul><li>배치 추론이 실행될 때만 자원을 사용하면 되기에, 비용 절감 가능</li><li>장애 대응 등 시간적 여유를 가지고 추론이 가능함 (단, 비즈니스가 이러한 여유를 허용할 경우)</li></ul><p>주의점:</p><ul><li>시간의 지남에 따라 데이터의 특성이 변화하는 상황이 발생한 경우 적기에 대응이 쉽지 않으므로, 모니터링 기준이 필요함.</li><li>소량의 데이터라도 짧은 주기에 한번씩 추론을 실행하여 결과를 확인하는 과정이 필요할 수 있음.</li></ul><p>&nbsp</p><hr><h2 id=2-순서에-대한-패턴>2. 순서에 대한 패턴<a hidden class=anchor aria-hidden=true href=#2-순서에-대한-패턴>#</a></h2><h3 id=21-동기-추론-패턴>2.1. 동기 추론 패턴<a hidden class=anchor aria-hidden=true href=#21-동기-추론-패턴>#</a></h3><p>개념과 구조:</p><ul><li>모델이 동작하는 서버에 요청을 하여 추론 결과가 나올 때까지 기다리는 구조를 동기추론 패턴이라 함.</li></ul><p>목적 또는 적용 예시:</p><ul><li>추론 이후의 단계가 추론 결과에 의존 하는 경우.</li><li>예시) 불량품 검출 모델 결과를 반환받아, 불량품을 정상 제품으로부터 분리 함.</li></ul><p>장점:</p><ul><li>각 작업이 순차적이고 직관적임.</li><li>개발이 다소 간단함.</li></ul><p>주의점:</p><ul><li>프로세스에 병목현상을 야기하는 작업단계가 있을 경우, 사용자는 추론 결과를 받기까지 기다려야 하는 시간이 길어짐.</li><li>따라서 작업의 속도를 개선하거나, 모델의 경량화 또는 비동기 추론 패턴을 적용한 프로세스를 고려하는 것이 적합함.</li></ul><p>&nbsp</p><h3 id=22-비동기-추론-패턴>2.2. 비동기 추론 패턴<a hidden class=anchor aria-hidden=true href=#22-비동기-추론-패턴>#</a></h3><p>개념과 구조:</p><ul><li>사용자는 추론 요청을 하고 결과가 반환 때까지 기다리지 않고 다른 작업을 수행할 수 있으며, 추론이 완료되었을 때 개별적으로 결과를 확인할 수 있음. (비동기적인 처리)</li><li>사용자의 요청을 큐 또는 캐시로 저장하여 순차적으로 추론한 뒤, 추론이 완료되었을 결과를 DB에 저장하고 사용자에게 추론 결과가 반환되었으며 확인이 가능함을 알림.</li></ul><p>목적 또는 적용 예시:</p><ul><li>비즈니스 로직에 따라, 모델의 결과를 즉시 반환하지 않아도 되는 경우.</li><li>모델의 추론 시간이 오래 걸리는 경우.</li></ul><p>장점:</p><ul><li>추론 과정에서 발생할 수 있는 병목현상을 해결할 수 있음.</li><li>어떻게 설계했는지에 따라 사용자 경험을 개선할 수 있음.</li></ul><p>주의점:</p><ul><li>사용자의 요청을 저장하고 추론하는 순서를 경우에 따라 선택해야하며, 시스템 장애가 발생하는 경우 대응 방법을 고려해야 함.</li></ul><p>&nbsp</p><hr><h2 id=3-2개-이상의-모델에-대한-추론-패턴>3. 2개 이상의 모델에 대한 추론 패턴<a hidden class=anchor aria-hidden=true href=#3-2개-이상의-모델에-대한-추론-패턴>#</a></h2><h3 id=31-직렬-마이크로서비스-패턴>3.1. 직렬 마이크로서비스 패턴<a hidden class=anchor aria-hidden=true href=#31-직렬-마이크로서비스-패턴>#</a></h3><p>개념과 구조:</p><ul><li>2개 이상의 모델 추론이 필요한 어플리케이션에서, 모델 간의 순서의 의존성이 존재하는 경우.</li><li>단, 여러 개의 추론 시스템을 마이크로서비스로 구현하여, 각 모델 간의 결합도를 낮춤.</li><li>모델이 구동되는 여러 개의 추론 마이크로서비스를 워크플로우 파이프라인을 통해 DAG(directed acyclic graph)의 형태로 연결하여 구현할 수 있음.</li></ul><p>목적 또는 적용 예시:</p><ul><li>여러 개의 모델이 순차적으로 실행되어 최종적으로 하나의 결과를 반환하는 유형에 적합.</li></ul><p>장점:</p><ul><li>모델과 추론 시스템의 사이즈가 커질 수록, 마이크로서비스 패턴은 리소스 비용을 효율적으로 관리할 수 있음.</li><li>독립적으로 구성되어 있기 때문에 직전 추론 결과에 따라 분기처리 또한 가능.</li></ul><p>주의점:</p><ul><li>동기 추론 패턴과 마찬가지로 추론에 걸리는 시간에 따라 병목현상이 발생할 수 있음.</li><li>마이크로서비스 패턴은 서버간 통신으로 인한 지연도 발생할 수 있음.</li></ul><p>&nbsp</p><h3 id=32-병렬-마이크로서비스-패턴>3.2. 병렬 마이크로서비스 패턴<a hidden class=anchor aria-hidden=true href=#32-병렬-마이크로서비스-패턴>#</a></h3><p>개념과 구조:</p><ul><li>여러 개의 추론 마이크로서비스가 의존관계 없이 병렬로 실행되어 결과가 저장됨. 필요에 따라서는 각 추론 결과를 마지막에 집계하는 구조도 가능함.</li></ul><p>목적 또는 적용 예시:</p><ul><li>하나의 데이터에 대해 여러가지의 모델이 추론을 해야하는 상황에 적합함.</li></ul><p>장점:</p><ul><li>의존 관계가 없어 유연하게 설계가 가능함.</li><li>각 모델의 추론 서버가 구별되어, 리소스 관리나 장애 대응이 용이해짐.</li></ul><p>주의점:</p><ul><li>각 추론 서버들의 결과 반환 속도가 다르므로, 결과를 집계하는 방식에 대한 고려가 필요함.</li></ul><p>&nbsp</p><hr><h2 id=4-캐싱-패턴>4. 캐싱 패턴<a hidden class=anchor aria-hidden=true href=#4-캐싱-패턴>#</a></h2><h3 id=41-추론-캐시-패턴>4.1. 추론 캐시 패턴<a hidden class=anchor aria-hidden=true href=#41-추론-캐시-패턴>#</a></h3><p>개념과 구조:</p><ul><li>추론 결과를 캐시로 저장하고, 추후 동일한 데이터에 대해 추론 요청이 있을 때는 추론할 필요 없이 캐시된 결과를 반환하는 개념.</li><li>입력된 데이터가 저장되고 식별 및 검색이 가능해야 함. 데이터에 매핑되어 저장된 추론 결과를 반환해야 하기 때문.</li></ul><p>목적 또는 적용 예시:</p><ul><li>동일한 데이터가 추후에도 입력될 수 있고, 추론 시간을 단축해야 하는 경우.</li></ul><p>장점:</p><ul><li>추론 속도를 단축할 수 있으며, 추론 시스템이 구동되는 리소스의 비용을 줄일 수 있음.</li></ul><p>주의점:</p><ul><li>입력 데이터가 적재되는 저장공간과 추론 결과가 저장되는 캐시로 인한 비용이 발생할 수 있음.</li><li>동일한 데이터가 발생되는 유형의 목적에 유효한 패턴이며, 그 외 &ldquo;유사한 데이터&rdquo; 수준인 경우에는 적용되지 않음.</li></ul><p>&nbsp</p><h3 id=42-데이터-캐시-패턴>4.2. 데이터 캐시 패턴<a hidden class=anchor aria-hidden=true href=#42-데이터-캐시-패턴>#</a></h3><p>개념과 구조:</p><ul><li>동일한 데이터에 대해 추론 요청이 있을 경우, 데이터 전처리 결과를 캐시하여 추론하는 경우. 추론 캐시 패턴과 유사하며 함께 사용될 수 있음.</li><li>추론 캐싱 패턴과 마찬가지로 입력 데이터가 식별이 가능해야 함.</li></ul><p>목적 또는 적용 예시:</p><ul><li>데이터 전처리, 피쳐 추출 등 데이터 처리와 관련된 시간이나 비용이 클 경우 적용할 수 있음.</li></ul><p>장점:</p><ul><li>빈번하게 발생하는 동일한 데이터 전처리와 피쳐 추출로 인해 발생하는 비용을 줄일 수 있음.</li></ul><p>주의점:</p><ul><li>추론 캐싱 패턴과 마찬가지로, 캐시가 적재되는 용량과 그에 따른 비용이 커질 수 있음.</li></ul><p>&nbsp</p><hr><h2 id=5-추론-시스템의-안티-패턴>5. 추론 시스템의 안티 패턴<a hidden class=anchor aria-hidden=true href=#5-추론-시스템의-안티-패턴>#</a></h2><p>추론 시스템을 구축할 때는 지양해야 하지만 간과하기 쉬운 안티 패턴이 몇 가지 있다.</p><h3 id=51-온라인-빅사이즈-패턴>5.1. 온라인 빅사이즈 패턴<a hidden class=anchor aria-hidden=true href=#51-온라인-빅사이즈-패턴>#</a></h3><p>개념:</p><ul><li>실시간 처리, 스트리밍 데이터에 대한 추론에 큰 규모의 모델을 적용, 이에 따라 서비스 지연이 발생하는 경우</li><li>배치 추론의 구조를 가지고 있지만, 1회 배치 추론의 시간이 배치 추론 주기를 초과하는 경우</li></ul><p>접근 방법:</p><ul><li>리소스 규모를 확대하여 처리 속도를 개선함.</li><li>2개 이상의 모델일 경우 가벼운 모델과 무거운 모델의 서비스를 분리함.</li><li>캐싱 패턴을 통해 속도를 개선함.</li><li>완벽하고 거대한 모델이 아닌 비즈니스 요구에 충족하는 수준의 모델을 개발함.</li></ul><h3 id=52-올인원-패턴>5.2. 올인원 패턴<a hidden class=anchor aria-hidden=true href=#52-올인원-패턴>#</a></h3><p>개념:</p><ul><li>하나의 서버에서 전처리, 2개 이상의 모델 등 모든 것을 가동하는 경우</li><li>활용하는 리소스의 비용은 절약할 수 있으나, 다음과 같은 측면에서 운영이 용이하지 않음.<ul><li>장애 대응</li><li>시스템 갱신</li><li>모델 갱신 및 관리</li><li>라이브러리 갱신</li></ul></li></ul><p>접근 방법:</p><ul><li>전처리, 추론 모델 서버 등을 마이크로서비스로 구현함.</li></ul><p>&nbsp</p><hr><h2 id=7-마무리하며>7. 마무리하며<a hidden class=anchor aria-hidden=true href=#7-마무리하며>#</a></h2><p>추론 시스템을 개발하기 위한 다양한 패턴과 고려해야할 점들을 훑어보았다. 기존의 데이터사이언티스트 관점에서 막막한 영역이었으나, 개념이 정리되어 앞으로의 업무에 도움이 많이 되었다. 현업에서는 훨씬 복잡한 서비스를 위해 위에서 정리한 패턴에 그치지 않고 이를 조합하거나 새로운 패턴을 고안할 것으로 생각된다. 정리한 내용을 토대로 앞으로는 다른 기업의 케이스 등을 분석해보고 업무에 참고할 수 있을 것 같다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wonyoungseo.github.io/tags/mlops/>mlops</a></li><li><a href=https://wonyoungseo.github.io/tags/ml/>ml</a></li><li><a href=https://wonyoungseo.github.io/tags/inference-system/>inference system</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>