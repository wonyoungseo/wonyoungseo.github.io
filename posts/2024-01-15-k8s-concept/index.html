<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes - 개념 정리 | Wonyoung's Tech Blog</title><meta name=keywords content="kubernetes,k8s"><meta name=description content="1 쿠버네티스 개념 아키텍처 1.1. 개념  컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템 구글에 의해 개발됨. CNCF에 기반을 둠  1.2. 주요 특징  자동화된 롤아웃 및 롤백  어플리케이션 업데이트 시 롤아웃을 자동으로 관리 문제 발생 시 이전 버전으로 롤백   서비스 접근 및 로드 밸런싱  클러스터 내의 어플리케이션에 쉬벡 접근 트래픽을 자동으로 분산   스케일링  리소스의 사용에 따라 자동 또는 수동으로 스케일링   자체 회복  실패한 컨테이너 재시작."><meta name=author content="Wonyoung Seo"><link rel=canonical href=https://wonyoungseo.github.io/posts/2024-01-15-k8s-concept/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.d8cbf60331b9ced42909130bf88f8b97d2eb3de242444dcc9e2df410ceb098b9.css integrity="sha256-2Mv2AzG5ztQpCRML+I+Ll9LrPeJCRE3Mni30EM6wmLk=" rel="preload stylesheet" as=style><link rel=icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Kubernetes - 개념 정리"><meta property="og:description" content="1 쿠버네티스 개념 아키텍처 1.1. 개념  컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템 구글에 의해 개발됨. CNCF에 기반을 둠  1.2. 주요 특징  자동화된 롤아웃 및 롤백  어플리케이션 업데이트 시 롤아웃을 자동으로 관리 문제 발생 시 이전 버전으로 롤백   서비스 접근 및 로드 밸런싱  클러스터 내의 어플리케이션에 쉬벡 접근 트래픽을 자동으로 분산   스케일링  리소스의 사용에 따라 자동 또는 수동으로 스케일링   자체 회복  실패한 컨테이너 재시작."><meta property="og:type" content="article"><meta property="og:url" content="https://wonyoungseo.github.io/posts/2024-01-15-k8s-concept/"><meta property="og:image" content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2024-01-10T21:33:01+09:00"><meta property="article:modified_time" content="2024-01-10T21:33:01+09:00"><meta property="og:site_name" content="WY's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wonyoungseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kubernetes - 개념 정리"><meta name=twitter:description content="1 쿠버네티스 개념 아키텍처 1.1. 개념  컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템 구글에 의해 개발됨. CNCF에 기반을 둠  1.2. 주요 특징  자동화된 롤아웃 및 롤백  어플리케이션 업데이트 시 롤아웃을 자동으로 관리 문제 발생 시 이전 버전으로 롤백   서비스 접근 및 로드 밸런싱  클러스터 내의 어플리케이션에 쉬벡 접근 트래픽을 자동으로 분산   스케일링  리소스의 사용에 따라 자동 또는 수동으로 스케일링   자체 회복  실패한 컨테이너 재시작."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes - 개념 정리","name":"Kubernetes - 개념 정리","description":"1 쿠버네티스 개념 아키텍처 1.1. 개념  컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템 구글에 의해 개발됨. CNCF에 기반을 둠  1.2. 주요 특징  자동화된 롤아웃 및 롤백  어플리케이션 업데이트 시 롤아웃을 자동으로 관리 문제 발생 시 이전 버전으로 롤백   서비스 접근 및  …","keywords":["kubernetes","k8s"],"articleBody":"1 쿠버네티스 개념 아키텍처 1.1. 개념  컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템 구글에 의해 개발됨. CNCF에 기반을 둠  1.2. 주요 특징  자동화된 롤아웃 및 롤백  어플리케이션 업데이트 시 롤아웃을 자동으로 관리 문제 발생 시 이전 버전으로 롤백   서비스 접근 및 로드 밸런싱  클러스터 내의 어플리케이션에 쉬벡 접근 트래픽을 자동으로 분산   스케일링  리소스의 사용에 따라 자동 또는 수동으로 스케일링   자체 회복  실패한 컨테이너 재시작. 건강하지 않은 컨테이너는 교체 준비되지 않은 노드로부터 어플리케이션 이전    2. 쿠버네티스 아키텍쳐와 주요 구성 요소    2.1. 아키텍처  Master ← → Node 구조로 이루어진 클러스터를 사용  마스터 컴포넌트  API 서버 (kube-apiserver): 쿠버네티스 API를 제공하며, 사용자와 내부 컴포넌트 간의 중재자 역할을 함 스케줄러 (kube-scheduler): 새로 생성된 파드를 어떤 노드에 할당할 지 결정 컨트롤러 매니저 (kube-controller-manager): 여러 컨트롤러를 실행. 노드 컨트롤러, 레플리케이션 컨트롤러 등이 존재함 etcd: 모든 클러스터 데이터를 저장하는 경량의 분산 키-값 저장소  노드 컴포넌트 Pod가 할당되어 있는 공간\n kubelet : 각 노드에서 실행되며, 파드 스펙(Spec)에 설명된 대로 컨테이너가 실행되고 있는지 확인 kube-proxy: 각 노드의 네트워크 규칙을 관리하여 네트워크 통신을 가능케 함 컨테이너 런타임: 컨테이너 실행을 담당하는 소프트웨어 (Docker, containerd, CRI-O 등)  2.2. 기능  클러스터 구성  먼저 쿠버네티스 클러스터를 구성. 클러스터는 여러 노드 (물리적 또는 가상머신)와 이들을 관리하는 마스터 노드로 구성됨 etcd 는 클러스터 관리에 사용되는 모든 데이터를 분산된 Key-Value 형태로 저장함. 마스터 간 충돌이 없도록 클러스터 내에서 잠금을 구현함.   API 서버와의 통신  사용자는 kubectl CLI 또는 API를 통해 API 서버와 통신함 이를 통해 파드의 생성, 업데이트, 삭제 등의 작업을 요청함   스케줄링과 실행  스케줄러는 새로운 파드에 대해 가장 적합한 노드를 선택함. kubelet은 해당 노드에서 파드의 컨테이너가 예상대로 실행되도록 관리함.   서비스 관리  kube-proxy는 서비스를 통한 네트워크 트래픽을 관리. 서비스는 파드 그룹에 안정적인 접근성을 제공함.   자동화된 롤아웃 및 롤백  Deployment를 통해 어플리케이션의 업데이트, 롤아웃 및 롤백을 자동으로 관리함   스케일링과 자체 치유  어플리케이션의 수요에 따라 자동으로 스케일링함. 실패한 파드를 재시작 하는 등의 자체 치유 기능을 제공함.    2.3. 주요 구성 요소 2.3.1. Pod 개념\n 쿠버네티스에서 배포할 수 있는 가장 작은 작업 단위 하나 이상의 컨테이너를 포함할 수 있으며, 이들은 스토리지와 네트워크를 공유 공유해야한다면 하나의 파드에서 구동시키는 것이 적합함  특징\n 컨테이너 그루핑:  하나 이상의 밀접하게 관련된 컨테이너를 그룹화 이 컨테이너들은 같은 컴퓨팅 리소스를 공유함   공유 리소스  파드 내 컨테이너는 같은 IP 주소와 포트공간을 공유함 서로 localhost를 통해 통신   일시적인 성격:  파드는 일시적. 파드가 삭제되면 그 안의 컨테이너도 함께 삭제됨 따라서 파드는 변경 가능한 리소스로 간주됨.   생명주기:  파드는 생성되고, 실행되고, 종료될 때 까지의 생명주기를 가짐. 파드가 종료되면, 쿠버네티스 클러스터에서 제거됨    사용 예\n 단일 컨테이너 파드: 대부분의 파드는 하나의 컨테이너만을 실행함 멀티 컨테이너 파드: 로깅, 데이터 백업, 데이터 처리와 같은 보조 기능을 수행하는 사이드카(sidecar) 컨테이너를 함께 포함하는 경우  2.3.2. Service 개념\n 서비스는 파드의 집합에 대한 안정적인 네트워크 주소를 제공함 서비스를 통해 파드 집합에 대한 접근을 관리하고, 로드 밸런싱 및 서비스 발견이 가능함 (service discovery) → 그냥 서비스 디스커버리라고 하면 되지, 자꾸 서비스발견 서비스발견 거려서 뭔말인가 했네  특징\n 안정적인 주소 제공: 서비스는 파드 집합에 지속적으로 접근할 수 있는 안정적인 IP주소와 포트를 제공함 로드 밸런싱: 서비스는 요청을 여러 파드에 분산시켜 로드 밸런싱을 수행함 서비스 발견: Service Discovery 서비스 타입: 다양한 서비스타입을 통해 다양한 네트워크 요구사항을 충족함  ClusterIP NodePort LoadBalancer ExternalName    사용 예\n ClusterIP: 클러스터 내부에서만 접근 가능한 서비스를 만들 때 사용 LoadBalancer: 클라우드 제공 업체의 로드밸런서를 사용하여 서비스에 대한 외부 접근을 관리할 때 사용  2.3.3. Deployment 개념\n 쿠버네티스에서 파드와 레플리카셋의 상태를 선언적으로 관리하는 API 오브젝트 어플리케이션의 배포, 업데이트, 스케일링 등을 자동화 하고 관리함  특징\n 자동화된 롤아웃과 롤백: 새로운 버전을 롤아웃하고 필요한 경우 이전 버전으로 롤백하는 프로세스를 자동화 상태 관리: 원하는 상태 (Desired State)를 정의하고, 쿠버네티스가 현상태(Current State)를 앞서 정의한 상태대로 유지함 선언적 업데이트: YAML 파일이나 JSON 형식을 사용하여 애플리케이션을 업데이트하는 방식을 선언함 스케일링: 파드의 수를 수동 또는 자동으로 조절하여 애플리케이션을 스케일링함  사용 예\n 새 버전 배포 스케일링: kubectl scale deployment 명령어를 사용하여 확장하거나 축소  2.3.4. ReplicaSet 개념\n 레플리카셋은 파드의 복제본을 유지 관리하는 쿠버네티스 오브젝트 파드의 원하는 복제본 수를 지정함 지정된 수의 파드 복제본이 항상 실행되고 있도록 보장함  특징\n 복제본 수 관리: 지정된 수의 파드 복제본을 유지함 자체 치유: 실패한 파드를 자동으로 대체하여 복제본 수를 유지함 유연한 파드 선택: 레이블 선택기(Label Selector)를 사용하여 관리할 파드를 결정함  사용 예\n 어플리케이션 가용성 보장: 레플리카셋은 어플리케이션의 가용성을 높이기 위해 여러 파드의 복제본을 두고 실행함. 부하 분산: 덕분에 트래픽이 분선되고 부하가 복제본에 균등하게 분배됨.  2.3.5. StatefulSet 개념\n Stateful한 pod를 관리하기 위한 controller.  특징\n pod들의 고유성과 순서를 보장함.  사용 예\n 마스터 노드가 가동된 후 순차적으로 워커 노드가 가동되어야 하는 경우를 보이는 database. Persistent Volume(PV)을 개별 포드로 생성하여 연결함. Pod가 비정상적으로 종료된 경우에도, 새로운 Pod가 PV를 담당함.  Reference  kubernetes official document Kodekloud Blog Post  ","wordCount":"723","inLanguage":"en","datePublished":"2024-01-10T21:33:01+09:00","dateModified":"2024-01-10T21:33:01+09:00","author":{"@type":"Person","name":"Wonyoung Seo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wonyoungseo.github.io/posts/2024-01-15-k8s-concept/"},"publisher":{"@type":"Organization","name":"Wonyoung's Tech Blog","logo":{"@type":"ImageObject","url":"https://wonyoungseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://wonyoungseo.github.io/ accesskey=h title="Tech Blog (Alt + H)">Tech Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://wonyoungseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://wonyoungseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wonyoungseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wonyoungseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://wonyoungseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Kubernetes - 개념 정리</h1><div class=post-meta>January 10, 2024&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Wonyoung Seo</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#1-%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4-%ea%b0%9c%eb%85%90-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="1 쿠버네티스 개념 아키텍처">1 쿠버네티스 개념 아키텍처</a><ul><li><a href=#11-%ea%b0%9c%eb%85%90 aria-label="1.1. 개념">1.1. 개념</a></li><li><a href=#12-%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95 aria-label="1.2. 주요 특징">1.2. 주요 특징</a></li></ul></li><li><a href=#2-%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4-%ec%95%84%ed%82%a4%ed%85%8d%ec%b3%90%ec%99%80-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c aria-label="2. 쿠버네티스 아키텍쳐와 주요 구성 요소">2. 쿠버네티스 아키텍쳐와 주요 구성 요소</a><ul><li><a href=#21-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="2.1. 아키텍처">2.1. 아키텍처</a><ul><li><a href=#%eb%a7%88%ec%8a%a4%ed%84%b0-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8 aria-label="마스터 컴포넌트">마스터 컴포넌트</a></li><li><a href=#%eb%85%b8%eb%93%9c-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8 aria-label="노드 컴포넌트">노드 컴포넌트</a></li></ul></li><li><a href=#22-%ea%b8%b0%eb%8a%a5 aria-label="2.2. 기능">2.2. 기능</a></li><li><a href=#23-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c aria-label="2.3. 주요 구성 요소">2.3. 주요 구성 요소</a><ul><li><a href=#231-pod aria-label="2.3.1. Pod">2.3.1. Pod</a></li><li><a href=#232-service aria-label="2.3.2. Service">2.3.2. Service</a></li><li><a href=#233-deployment aria-label="2.3.3. Deployment">2.3.3. Deployment</a></li><li><a href=#234-replicaset aria-label="2.3.4. ReplicaSet">2.3.4. ReplicaSet</a></li><li><a href=#235-statefulset aria-label="2.3.5. StatefulSet">2.3.5. StatefulSet</a></li></ul></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h1 id=1-쿠버네티스-개념-아키텍처>1 쿠버네티스 개념 아키텍처<a hidden class=anchor aria-hidden=true href=#1-쿠버네티스-개념-아키텍처>#</a></h1><h2 id=11-개념>1.1. 개념<a hidden class=anchor aria-hidden=true href=#11-개념>#</a></h2><ul><li>컨테이너화 된 어플리케이션의 배포, 확장, 운영을 자동화하기 위한 오픈소스 시스템</li><li>구글에 의해 개발됨.</li><li>CNCF에 기반을 둠</li></ul><h2 id=12-주요-특징>1.2. 주요 특징<a hidden class=anchor aria-hidden=true href=#12-주요-특징>#</a></h2><ul><li>자동화된 롤아웃 및 롤백<ul><li>어플리케이션 업데이트 시 롤아웃을 자동으로 관리</li><li>문제 발생 시 이전 버전으로 롤백</li></ul></li><li>서비스 접근 및 로드 밸런싱<ul><li>클러스터 내의 어플리케이션에 쉬벡 접근</li><li>트래픽을 자동으로 분산</li></ul></li><li>스케일링<ul><li>리소스의 사용에 따라 자동 또는 수동으로 스케일링</li></ul></li><li>자체 회복<ul><li>실패한 컨테이너 재시작.</li><li>건강하지 않은 컨테이너는 교체</li><li>준비되지 않은 노드로부터 어플리케이션 이전</li></ul></li></ul><h1 id=2-쿠버네티스-아키텍쳐와-주요-구성-요소>2. 쿠버네티스 아키텍쳐와 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#2-쿠버네티스-아키텍쳐와-주요-구성-요소>#</a></h1><figure><center><img src=/2024-01-15-k8s-concept/1.png></center></figure><h2 id=21-아키텍처>2.1. 아키텍처<a hidden class=anchor aria-hidden=true href=#21-아키텍처>#</a></h2><ul><li>Master ← → Node 구조로 이루어진 클러스터를 사용</li></ul><h3 id=마스터-컴포넌트>마스터 컴포넌트<a hidden class=anchor aria-hidden=true href=#마스터-컴포넌트>#</a></h3><ul><li>API 서버 (kube-apiserver): 쿠버네티스 API를 제공하며, 사용자와 내부 컴포넌트 간의 중재자 역할을 함</li><li>스케줄러 (kube-scheduler): 새로 생성된 파드를 어떤 노드에 할당할 지 결정</li><li>컨트롤러 매니저 (kube-controller-manager): 여러 컨트롤러를 실행. 노드 컨트롤러, 레플리케이션 컨트롤러 등이 존재함</li><li>etcd: 모든 클러스터 데이터를 저장하는 경량의 분산 키-값 저장소</li></ul><h3 id=노드-컴포넌트>노드 컴포넌트<a hidden class=anchor aria-hidden=true href=#노드-컴포넌트>#</a></h3><p>Pod가 할당되어 있는 공간</p><ul><li>kubelet : 각 노드에서 실행되며, 파드 스펙(Spec)에 설명된 대로 컨테이너가 실행되고 있는지 확인</li><li>kube-proxy: 각 노드의 네트워크 규칙을 관리하여 네트워크 통신을 가능케 함</li><li>컨테이너 런타임: 컨테이너 실행을 담당하는 소프트웨어 (Docker, containerd, CRI-O 등)</li></ul><h2 id=22-기능>2.2. 기능<a hidden class=anchor aria-hidden=true href=#22-기능>#</a></h2><ul><li>클러스터 구성<ul><li>먼저 쿠버네티스 클러스터를 구성.</li><li>클러스터는 여러 노드 (물리적 또는 가상머신)와 이들을 관리하는 마스터 노드로 구성됨</li><li>etcd 는 클러스터 관리에 사용되는 모든 데이터를 분산된 Key-Value 형태로 저장함. 마스터 간 충돌이 없도록 클러스터 내에서 잠금을 구현함.</li></ul></li><li>API 서버와의 통신<ul><li>사용자는 kubectl CLI 또는 API를 통해 API 서버와 통신함</li><li>이를 통해 파드의 생성, 업데이트, 삭제 등의 작업을 요청함</li></ul></li><li>스케줄링과 실행<ul><li>스케줄러는 새로운 파드에 대해 가장 적합한 노드를 선택함.</li><li>kubelet은 해당 노드에서 파드의 컨테이너가 예상대로 실행되도록 관리함.</li></ul></li><li>서비스 관리<ul><li>kube-proxy는 서비스를 통한 네트워크 트래픽을 관리.</li><li>서비스는 파드 그룹에 안정적인 접근성을 제공함.</li></ul></li><li>자동화된 롤아웃 및 롤백<ul><li>Deployment를 통해 어플리케이션의 업데이트, 롤아웃 및 롤백을 자동으로 관리함</li></ul></li><li>스케일링과 자체 치유<ul><li>어플리케이션의 수요에 따라 자동으로 스케일링함.</li><li>실패한 파드를 재시작 하는 등의 자체 치유 기능을 제공함.</li></ul></li></ul><h2 id=23-주요-구성-요소>2.3. 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#23-주요-구성-요소>#</a></h2><h3 id=231-pod>2.3.1. Pod<a hidden class=anchor aria-hidden=true href=#231-pod>#</a></h3><p>개념</p><ul><li>쿠버네티스에서 배포할 수 있는 가장 작은 작업 단위</li><li>하나 이상의 컨테이너를 포함할 수 있으며, 이들은 스토리지와 네트워크를 공유</li><li>공유해야한다면 하나의 파드에서 구동시키는 것이 적합함</li></ul><p>특징</p><ul><li>컨테이너 그루핑:<ul><li>하나 이상의 밀접하게 관련된 컨테이너를 그룹화</li><li>이 컨테이너들은 같은 컴퓨팅 리소스를 공유함</li></ul></li><li>공유 리소스<ul><li>파드 내 컨테이너는 같은 IP 주소와 포트공간을 공유함</li><li>서로 localhost를 통해 통신</li></ul></li><li>일시적인 성격:<ul><li>파드는 일시적.</li><li>파드가 삭제되면 그 안의 컨테이너도 함께 삭제됨</li><li>따라서 파드는 변경 가능한 리소스로 간주됨.</li></ul></li><li>생명주기:<ul><li>파드는 생성되고, 실행되고, 종료될 때 까지의 생명주기를 가짐.</li><li>파드가 종료되면, 쿠버네티스 클러스터에서 제거됨</li></ul></li></ul><p>사용 예</p><ul><li>단일 컨테이너 파드: 대부분의 파드는 하나의 컨테이너만을 실행함</li><li>멀티 컨테이너 파드: 로깅, 데이터 백업, 데이터 처리와 같은 보조 기능을 수행하는 사이드카(sidecar) 컨테이너를 함께 포함하는 경우</li></ul><h3 id=232-service>2.3.2. Service<a hidden class=anchor aria-hidden=true href=#232-service>#</a></h3><p>개념</p><ul><li>서비스는 파드의 집합에 대한 안정적인 네트워크 주소를 제공함</li><li>서비스를 통해 파드 집합에 대한 접근을 관리하고, 로드 밸런싱 및 서비스 발견이 가능함 (service discovery) → 그냥 서비스 디스커버리라고 하면 되지, 자꾸 서비스발견 서비스발견 거려서 뭔말인가 했네</li></ul><p>특징</p><ul><li>안정적인 주소 제공: 서비스는 파드 집합에 지속적으로 접근할 수 있는 안정적인 IP주소와 포트를 제공함</li><li>로드 밸런싱: 서비스는 요청을 여러 파드에 분산시켜 로드 밸런싱을 수행함</li><li>서비스 발견: Service Discovery</li><li>서비스 타입: 다양한 서비스타입을 통해 다양한 네트워크 요구사항을 충족함<ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li><li>ExternalName</li></ul></li></ul><p>사용 예</p><ul><li>ClusterIP: 클러스터 내부에서만 접근 가능한 서비스를 만들 때 사용</li><li>LoadBalancer: 클라우드 제공 업체의 로드밸런서를 사용하여 서비스에 대한 외부 접근을 관리할 때 사용</li></ul><h3 id=233-deployment>2.3.3. Deployment<a hidden class=anchor aria-hidden=true href=#233-deployment>#</a></h3><p>개념</p><ul><li>쿠버네티스에서 파드와 레플리카셋의 상태를 선언적으로 관리하는 API 오브젝트</li><li>어플리케이션의 배포, 업데이트, 스케일링 등을 자동화 하고 관리함</li></ul><p>특징</p><ul><li>자동화된 롤아웃과 롤백: 새로운 버전을 롤아웃하고 필요한 경우 이전 버전으로 롤백하는 프로세스를 자동화</li><li>상태 관리: 원하는 상태 (Desired State)를 정의하고, 쿠버네티스가 현상태(Current State)를 앞서 정의한 상태대로 유지함</li><li>선언적 업데이트: YAML 파일이나 JSON 형식을 사용하여 애플리케이션을 업데이트하는 방식을 선언함</li><li>스케일링: 파드의 수를 수동 또는 자동으로 조절하여 애플리케이션을 스케일링함</li></ul><p>사용 예</p><ul><li>새 버전 배포</li><li>스케일링: kubectl scale deployment 명령어를 사용하여 확장하거나 축소</li></ul><h3 id=234-replicaset>2.3.4. ReplicaSet<a hidden class=anchor aria-hidden=true href=#234-replicaset>#</a></h3><p>개념</p><ul><li>레플리카셋은 파드의 복제본을 유지 관리하는 쿠버네티스 오브젝트</li><li>파드의 원하는 복제본 수를 지정함</li><li>지정된 수의 파드 복제본이 항상 실행되고 있도록 보장함</li></ul><p>특징</p><ul><li>복제본 수 관리: 지정된 수의 파드 복제본을 유지함</li><li>자체 치유: 실패한 파드를 자동으로 대체하여 복제본 수를 유지함</li><li>유연한 파드 선택: 레이블 선택기(Label Selector)를 사용하여 관리할 파드를 결정함</li></ul><p>사용 예</p><ul><li>어플리케이션 가용성 보장: 레플리카셋은 어플리케이션의 가용성을 높이기 위해 여러 파드의 복제본을 두고 실행함.</li><li>부하 분산: 덕분에 트래픽이 분선되고 부하가 복제본에 균등하게 분배됨.</li></ul><h3 id=235-statefulset>2.3.5. StatefulSet<a hidden class=anchor aria-hidden=true href=#235-statefulset>#</a></h3><p>개념</p><ul><li>Stateful한 pod를 관리하기 위한 controller.</li></ul><p>특징</p><ul><li>pod들의 고유성과 순서를 보장함.</li></ul><p>사용 예</p><ul><li>마스터 노드가 가동된 후 순차적으로 워커 노드가 가동되어야 하는 경우를 보이는 database.</li><li>Persistent Volume(PV)을 개별 포드로 생성하여 연결함. Pod가 비정상적으로 종료된 경우에도, 새로운 Pod가 PV를 담당함.</li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://kubernetes.io/ko/docs/concepts/ target=_blank>kubernetes official document</a></li><li><a href=https://kodekloud.com/blog/kubernetes-concepts-explained/ target=_blank>Kodekloud Blog Post</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wonyoungseo.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=https://wonyoungseo.github.io/tags/k8s/>k8s</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2023</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>